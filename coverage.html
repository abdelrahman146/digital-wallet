
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>v1: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/abdelrahman146/digital-wallet/api/backoffice/v1/account_handler.go (0.0%)</option>
				
				<option value="file1">github.com/abdelrahman146/digital-wallet/api/backoffice/v1/audit_handler.go (0.0%)</option>
				
				<option value="file2">github.com/abdelrahman146/digital-wallet/api/backoffice/v1/exchange_handler.go (0.0%)</option>
				
				<option value="file3">github.com/abdelrahman146/digital-wallet/api/backoffice/v1/program_handler.go (0.0%)</option>
				
				<option value="file4">github.com/abdelrahman146/digital-wallet/api/backoffice/v1/setup.go (0.0%)</option>
				
				<option value="file5">github.com/abdelrahman146/digital-wallet/api/backoffice/v1/tier_handler.go (0.0%)</option>
				
				<option value="file6">github.com/abdelrahman146/digital-wallet/api/backoffice/v1/transaction_handler.go (0.0%)</option>
				
				<option value="file7">github.com/abdelrahman146/digital-wallet/api/backoffice/v1/trigger_handler.go (0.0%)</option>
				
				<option value="file8">github.com/abdelrahman146/digital-wallet/api/backoffice/v1/user_handler.go (0.0%)</option>
				
				<option value="file9">github.com/abdelrahman146/digital-wallet/api/backoffice/v1/wallet_handler.go (0.0%)</option>
				
				<option value="file10">github.com/abdelrahman146/digital-wallet/db/seed.go (0.0%)</option>
				
				<option value="file11">github.com/abdelrahman146/digital-wallet/docs/docs.go (0.0%)</option>
				
				<option value="file12">github.com/abdelrahman146/digital-wallet/internal/model/account.go (0.0%)</option>
				
				<option value="file13">github.com/abdelrahman146/digital-wallet/internal/model/audit.go (0.0%)</option>
				
				<option value="file14">github.com/abdelrahman146/digital-wallet/internal/model/auditable.go (0.0%)</option>
				
				<option value="file15">github.com/abdelrahman146/digital-wallet/internal/model/exchange.go (0.0%)</option>
				
				<option value="file16">github.com/abdelrahman146/digital-wallet/internal/model/program.go (0.0%)</option>
				
				<option value="file17">github.com/abdelrahman146/digital-wallet/internal/model/tier.go (0.0%)</option>
				
				<option value="file18">github.com/abdelrahman146/digital-wallet/internal/model/transaction.go (0.0%)</option>
				
				<option value="file19">github.com/abdelrahman146/digital-wallet/internal/model/trigger.go (0.0%)</option>
				
				<option value="file20">github.com/abdelrahman146/digital-wallet/internal/model/user.go (0.0%)</option>
				
				<option value="file21">github.com/abdelrahman146/digital-wallet/internal/model/wallet.go (0.0%)</option>
				
				<option value="file22">github.com/abdelrahman146/digital-wallet/internal/repository/account_repo.go (0.0%)</option>
				
				<option value="file23">github.com/abdelrahman146/digital-wallet/internal/repository/audit_repo.go (0.0%)</option>
				
				<option value="file24">github.com/abdelrahman146/digital-wallet/internal/repository/exchange_repo.go (0.0%)</option>
				
				<option value="file25">github.com/abdelrahman146/digital-wallet/internal/repository/program_repo.go (0.0%)</option>
				
				<option value="file26">github.com/abdelrahman146/digital-wallet/internal/repository/tier_repo.go (0.0%)</option>
				
				<option value="file27">github.com/abdelrahman146/digital-wallet/internal/repository/transaction_repo.go (0.0%)</option>
				
				<option value="file28">github.com/abdelrahman146/digital-wallet/internal/repository/trigger_repo.go (0.0%)</option>
				
				<option value="file29">github.com/abdelrahman146/digital-wallet/internal/repository/user_repo.go (0.0%)</option>
				
				<option value="file30">github.com/abdelrahman146/digital-wallet/internal/repository/wallet_repo.go (0.0%)</option>
				
				<option value="file31">github.com/abdelrahman146/digital-wallet/internal/resource/gorm.go (0.0%)</option>
				
				<option value="file32">github.com/abdelrahman146/digital-wallet/internal/resource/sarama.go (0.0%)</option>
				
				<option value="file33">github.com/abdelrahman146/digital-wallet/internal/service/account_service.go (0.0%)</option>
				
				<option value="file34">github.com/abdelrahman146/digital-wallet/internal/service/audit_service.go (0.0%)</option>
				
				<option value="file35">github.com/abdelrahman146/digital-wallet/internal/service/ev.go (0.0%)</option>
				
				<option value="file36">github.com/abdelrahman146/digital-wallet/internal/service/exchange_service.go (0.0%)</option>
				
				<option value="file37">github.com/abdelrahman146/digital-wallet/internal/service/program_service.go (0.0%)</option>
				
				<option value="file38">github.com/abdelrahman146/digital-wallet/internal/service/tier_service.go (0.0%)</option>
				
				<option value="file39">github.com/abdelrahman146/digital-wallet/internal/service/transaction_service.go (0.0%)</option>
				
				<option value="file40">github.com/abdelrahman146/digital-wallet/internal/service/trigger_service.go (0.0%)</option>
				
				<option value="file41">github.com/abdelrahman146/digital-wallet/internal/service/user_service.go (0.0%)</option>
				
				<option value="file42">github.com/abdelrahman146/digital-wallet/internal/service/wallet_service.go (0.0%)</option>
				
				<option value="file43">github.com/abdelrahman146/digital-wallet/main.go (0.0%)</option>
				
				<option value="file44">github.com/abdelrahman146/digital-wallet/pkg/api/authentication.go (0.0%)</option>
				
				<option value="file45">github.com/abdelrahman146/digital-wallet/pkg/api/authorization.go (0.0%)</option>
				
				<option value="file46">github.com/abdelrahman146/digital-wallet/pkg/api/context.go (0.0%)</option>
				
				<option value="file47">github.com/abdelrahman146/digital-wallet/pkg/api/helpers.go (0.0%)</option>
				
				<option value="file48">github.com/abdelrahman146/digital-wallet/pkg/api/response.go (0.0%)</option>
				
				<option value="file49">github.com/abdelrahman146/digital-wallet/pkg/config/config.go (0.0%)</option>
				
				<option value="file50">github.com/abdelrahman146/digital-wallet/pkg/errs/errors.go (0.0%)</option>
				
				<option value="file51">github.com/abdelrahman146/digital-wallet/pkg/errs/errs.go (0.0%)</option>
				
				<option value="file52">github.com/abdelrahman146/digital-wallet/pkg/errs/handle_error.go (0.0%)</option>
				
				<option value="file53">github.com/abdelrahman146/digital-wallet/pkg/logger/logger.go (0.0%)</option>
				
				<option value="file54">github.com/abdelrahman146/digital-wallet/pkg/logger/zap_logger.go (0.0%)</option>
				
				<option value="file55">github.com/abdelrahman146/digital-wallet/pkg/rules_engine/engine.go (85.7%)</option>
				
				<option value="file56">github.com/abdelrahman146/digital-wallet/pkg/rules_engine/operators.go (62.2%)</option>
				
				<option value="file57">github.com/abdelrahman146/digital-wallet/pkg/rules_engine/rule.go (0.0%)</option>
				
				<option value="file58">github.com/abdelrahman146/digital-wallet/pkg/rules_engine/utils.go (61.5%)</option>
				
				<option value="file59">github.com/abdelrahman146/digital-wallet/pkg/types/interval.go (0.0%)</option>
				
				<option value="file60">github.com/abdelrahman146/digital-wallet/pkg/types/jsonb.go (0.0%)</option>
				
				<option value="file61">github.com/abdelrahman146/digital-wallet/pkg/utils/dates.go (83.3%)</option>
				
				<option value="file62">github.com/abdelrahman146/digital-wallet/pkg/utils/helpers.go (0.0%)</option>
				
				<option value="file63">github.com/abdelrahman146/digital-wallet/pkg/validator/validation.go (0.0%)</option>
				
				<option value="file64">github.com/abdelrahman146/digital-wallet/pkg/validator/validator.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package backofficev1

import (
        "github.com/abdelrahman146/digital-wallet/internal/service"
        "github.com/abdelrahman146/digital-wallet/pkg/api"
        "github.com/abdelrahman146/digital-wallet/pkg/errs"
        "github.com/abdelrahman146/digital-wallet/pkg/logger"
        "github.com/abdelrahman146/digital-wallet/pkg/validator"
        "github.com/gofiber/fiber/v2"
)

type accountHandler struct {
        services *service.Services
}

func NewAccountHandler(appGroup fiber.Router, services *service.Services) <span class="cov0" title="0">{
        handler := &amp;accountHandler{
                services: services,
        }
        handler.Setup(appGroup)
}</span>

func (h *accountHandler) Setup(appGroup fiber.Router) <span class="cov0" title="0">{
        group := appGroup.Group("wallets/:walletId/accounts")
        group.Get("/", h.GetWalletAccounts)
        group.Post("/", h.CreateAccount)
        group.Get("/sum", h.GetWalletAccountsSum)
        group.Get("/:accountId", h.GetAccountByID)
        group.Delete("/:accountId", h.DeleteAccount)
        group.Get("/:accountId/transactions", h.GetAccountTransactionsByID)
        group.Post("/:accountId/transactions/sum", h.GetAccountTransactionsSum)
}</span>

// GetWalletAccounts retrieves all accounts of a wallet
// @Summary Get all accounts of a wallet
// @Description Get all accounts of a wallet
// @Tags Account
// @Param walletId path string true "Wallet ID"
// @Param page query int false "Page"
// @Param limit query int false "Limit"
// @Success 200 {object} api.SuccessResponse{result=[]model.Account}
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/wallets/{walletId}/accounts [get]
func (h *accountHandler) GetWalletAccounts(c *fiber.Ctx) error <span class="cov0" title="0">{
        page, limit, err := api.GetPageAndLimit(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">walletId := c.Params("walletId")
        accounts, err := h.services.Account.GetWalletAccounts(c.Context(), walletId, page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(api.NewSuccessResponse(accounts))</span>
}

// GetWalletAccountsSum retrieves the sum of all accounts of a wallet
// @Summary Get the sum of all accounts of a wallet
// @Description Get the sum of all accounts of a wallet
// @Tags Account
// @Param walletId path string true "Wallet ID"
// @Success 200 {object} api.SuccessResponse{result=float64}
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/wallets/{walletId}/accounts/sum [get]
func (h *accountHandler) GetWalletAccountsSum(c *fiber.Ctx) error <span class="cov0" title="0">{
        walletId := c.Params("walletId")
        sum, err := h.services.Account.GetWalletAccountsSum(c.Context(), walletId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(api.NewSuccessResponse(sum))</span>
}

// GetAccountByID retrieves an account by its ID
// @Summary Get an account by its ID
// @Description Get an account by its ID
// @Tags Account
// @Param walletId path string true "Wallet ID"
// @Param accountId path string true "Account ID"
// @Success 200 {object} api.SuccessResponse{result=model.Account}
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/wallets/{walletId}/accounts/{accountId} [get]
func (h *accountHandler) GetAccountByID(c *fiber.Ctx) error <span class="cov0" title="0">{
        id := c.Params("accountId")
        account, err := h.services.Account.GetAccount(c.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(api.NewSuccessResponse(account))</span>
}

// CreateAccount creates an account
// @Summary Create an account
// @Description Create an account based on the provided request
// @Tags Account
// @Accept json
// @Produce json
// @Param walletId path string true "Wallet ID"
// @Param account body object true "Create Account Request"
// @Success 201 {object} api.SuccessResponse{result=model.Account}
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/wallets/{walletId}/accounts [post]
func (h *accountHandler) CreateAccount(c *fiber.Ctx) error <span class="cov0" title="0">{
        walletId := c.Params("walletId")
        var req struct {
                UserID string `json:"userId,omitempty" validate:"required"`
        }

        // Parse request body
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(c.Context()).Error("Invalid body request", logger.Field("error", err))
                return errs.NewBadRequestError("Invalid body request", "INVALID_BODY_REQUEST", err)
        }</span>

        // Validate request
        <span class="cov0" title="0">if err := validator.GetValidator().ValidateStruct(req); err != nil </span><span class="cov0" title="0">{
                fields := validator.GetValidator().GetValidationErrors(err)
                api.GetLogger(c.Context()).Error("Invalid request", logger.Field("fields", fields))
                return errs.NewValidationError("Invalid request", "INVALID_BODY_REQUEST", fields)
        }</span>

        <span class="cov0" title="0">account, err := h.services.Account.CreateAccount(c.Context(), walletId, req.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusCreated).JSON(api.NewSuccessResponse(account))</span>
}

// GetAccountTransactionsByID retrieves all transactions of an account
// @Summary Get all transactions of an account
// @Description Get all transactions of an account
// @Tags Account
// @Param walletId path string true "Wallet ID"
// @Param accountId path string true "Account ID"
// @Param page query int false "Page"
// @Param limit query int false "Limit"
// @Success 200 {object} api.SuccessResponse{result=[]model.Transaction}
// @Failure 400 {object} api.ErrorResponse
func (h *accountHandler) GetAccountTransactionsByID(c *fiber.Ctx) error <span class="cov0" title="0">{
        id := c.Params("accountId")
        walletId := c.Params("walletId")
        page, limit, err := api.GetPageAndLimit(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">transactions, err := h.services.Transaction.GetAccountTransactions(c.Context(), walletId, id, page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(api.NewSuccessResponse(transactions))</span>
}

// DeleteAccount deletes an account
// @Summary Delete an account
// @Description Delete an account
// @Tags Account
// @Param walletId path string true "Wallet ID"
// @Param accountId path string true "Account ID"
// @Success 202 {object} api.SuccessResponse
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/wallets/{walletId}/accounts/{accountId} [delete]
func (h *accountHandler) DeleteAccount(c *fiber.Ctx) error <span class="cov0" title="0">{
        id := c.Params("accountId")
        err := h.services.Account.DeleteAccount(c.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusAccepted).JSON(api.NewSuccessResponse(nil))</span>
}

// GetAccountTransactions retrieves all transactions of an account
// @Summary Get all transactions of an account
// @Description Get all transactions of an account
// @Tags Account
// @Param walletId path string true "Wallet ID"
// @Param accountId path string true "Account ID"
// @Param page query int false "Page"
// @Param limit query int false "Limit"
// @Success 200 {object} api.SuccessResponse{result=[]model.Transaction}
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/wallets/{walletId}/accounts/{accountId}/transactions [get]
func (h *accountHandler) GetAccountTransactions(c *fiber.Ctx) error <span class="cov0" title="0">{
        accountId := c.Params("accountId")
        walletId := c.Params("walletId")
        page, limit, err := api.GetPageAndLimit(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">transactions, err := h.services.Transaction.GetAccountTransactions(c.Context(), walletId, accountId, page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(api.NewSuccessResponse(transactions))</span>
}

// GetAccountTransactionsSum retrieves the sum of all transactions of an account
// @Summary Get the sum of all transactions of an account
// @Description Get the sum of all transactions of an account
// @Tags Account
// @Param walletId path string true "Wallet ID"
// @Param accountId path string true "Account ID"
// @Success 200 {object} api.SuccessResponse{result=float64}
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/wallets/{walletId}/accounts/{accountId}/transactions/sum [get]
func (h *accountHandler) GetAccountTransactionsSum(c *fiber.Ctx) error <span class="cov0" title="0">{
        accountId := c.Params("accountId")
        walletId := c.Params("walletId")
        sum, err := h.services.Transaction.GetAccountTransactionSum(c.Context(), walletId, accountId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(api.NewSuccessResponse(sum))</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package backofficev1

import (
        "github.com/abdelrahman146/digital-wallet/internal/service"
        "github.com/abdelrahman146/digital-wallet/pkg/api"
        "github.com/gofiber/fiber/v2"
)

type auditHandler struct {
        services *service.Services
}

func NewAuditHandler(appGroup fiber.Router, services *service.Services) <span class="cov0" title="0">{
        handler := &amp;auditHandler{services: services}
        handler.Setup(appGroup)
}</span>

func (h *auditHandler) Setup(appGroup fiber.Router) <span class="cov0" title="0">{
        group := appGroup.Group("audit")
        group.Get("/table/:table", h.GetTableAuditLogs)
        group.Get("/record/:table/:recordId", h.GetRecordAuditLogs)
        group.Get("/actor/:actor/:actorId", h.GetActorAuditLogs)
}</span>

// GetTableAuditLogs retrieves all audit logs of a table
// @Summary Get all audit logs of a table
// @Description Get all audit logs of a table
// @Tags Audit
// @Param table path string true "Table"
// @Param page query int false "Page"
// @Param limit query int false "Limit"
// @Success 200 {object} api.SuccessResponse{result=[]model.Audit}
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/audit/table/{table} [get]
func (h *auditHandler) GetTableAuditLogs(c *fiber.Ctx) error <span class="cov0" title="0">{
        table := c.Params("table")
        page, limit, err := api.GetPageAndLimit(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">audits, err := h.services.Audit.GetTableAuditLogs(c.Context(), table, page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(api.NewSuccessResponse(audits))</span>
}

// GetRecordAuditLogs retrieves all audit logs of a record
// @Summary Get all audit logs of a record
// @Description Get all audit logs of a record
// @Tags Audit
// @Param table path string true "Table"
// @Param recordId path string true "Record ID"
// @Param page query int false "Page"
// @Param limit query int false "Limit"
// @Success 200 {object} api.SuccessResponse{result=[]model.Audit}
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/audit/record/{table}/{recordId} [get]
func (h *auditHandler) GetRecordAuditLogs(c *fiber.Ctx) error <span class="cov0" title="0">{
        table := c.Params("table")
        recordId := c.Params("recordId")
        page, limit, err := api.GetPageAndLimit(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">audits, err := h.services.Audit.GetRecordAuditLogs(c.Context(), table, recordId, page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(api.NewSuccessResponse(audits))</span>
}

// GetActorAuditLogs retrieves all audit logs of an actor
// @Summary Get all audit logs of an actor
// @Description Get all audit logs of an actor
// @Tags Audit
// @Param actor path string true "Actor"
// @Param actorId path string true "Actor ID"
// @Param page query int false "Page"
// @Param limit query int false "Limit"
// @Success 200 {object} api.SuccessResponse{result=[]model.Audit}
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/audit/actor/{actor}/{actorId} [get]
func (h *auditHandler) GetActorAuditLogs(c *fiber.Ctx) error <span class="cov0" title="0">{
        actor := c.Params("actor")
        actorId := c.Params("actorId")
        page, limit, err := api.GetPageAndLimit(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">audits, err := h.services.Audit.GetActorAuditLogs(c.Context(), actor, actorId, page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(api.NewSuccessResponse(audits))</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package backofficev1

import (
        "github.com/abdelrahman146/digital-wallet/internal/service"
        "github.com/abdelrahman146/digital-wallet/pkg/api"
        "github.com/abdelrahman146/digital-wallet/pkg/errs"
        "github.com/abdelrahman146/digital-wallet/pkg/logger"
        "github.com/gofiber/fiber/v2"
        "github.com/shopspring/decimal"
)

type exchangeRateHandler struct {
        services *service.Services
}

func NewExchangeRateHandler(appGroup fiber.Router, services *service.Services) <span class="cov0" title="0">{
        handler := &amp;exchangeRateHandler{
                services: services,
        }
        handler.Setup(appGroup)
}</span>

func (h *exchangeRateHandler) Setup(appGroup fiber.Router) <span class="cov0" title="0">{
        group := appGroup.Group("exchange-rates")
        group.Post("/", h.CreateExchangeRate)
        group.Get("/", h.GetExchangeRates)
        group.Get("/wallets/:walletId", h.GetExchangeRatesByWalletID)
        group.Put("/wallets/:walletId", h.UpdateExchangeRate)
        group.Delete("/wallets/:walletId", h.DeleteExchangeRate)
}</span>

// CreateExchangeRate creates a new exchange rate
// @Summary Create a new exchange rate
// @Description Create an exchange rate based on the provided request
// @Tags Exchange Rate
// @Accept json
// @Produce json
// @Param exchangeRate body service.CreateExchangeRateRequest true "Create Exchange Rate Request"
// @Success 201 {object} api.SuccessResponse{result=model.ExchangeRate}
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/exchange-rates [post]
func (h *exchangeRateHandler) CreateExchangeRate(c *fiber.Ctx) error <span class="cov0" title="0">{
        var req service.CreateExchangeRateRequest
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                return errs.NewBadRequestError("Invalid body request", "INVALID_BODY_REQUEST", err)
        }</span>
        <span class="cov0" title="0">exchangeRate, err := h.services.ExchangeRate.CreateExchangeRate(c.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusCreated).JSON(api.NewSuccessResponse(exchangeRate))</span>
}

// GetExchangeRates retrieves all exchange rates
// @Summary Get all exchange rates
// @Description Get all exchange rates
// @Tags Exchange Rate
// @Param page query int false "Page"
// @Param limit query int false "Limit"
// @Success 200 {object} api.SuccessResponse{result=[]model.ExchangeRate}
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/exchange-rates [get]
func (h *exchangeRateHandler) GetExchangeRates(c *fiber.Ctx) error <span class="cov0" title="0">{
        page, limit, err := api.GetPageAndLimit(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">exchangeRates, err := h.services.ExchangeRate.GetExchangeRates(c.Context(), page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(api.NewSuccessResponse(exchangeRates))</span>
}

// GetExchangeRatesByWalletID retrieves all exchange rates of a wallet
// @Summary Get all exchange rates of a wallet
// @Description Get all exchange rates of a wallet
// @Tags Exchange Rate
// @Param walletId path string true "Wallet ID"
// @Param page query int false "Page"
// @Param limit query int false "Limit"
// @Success 200 {object} api.SuccessResponse{result=[]model.ExchangeRate}
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/exchange-rates/wallets/{walletId} [get]
func (h *exchangeRateHandler) GetExchangeRatesByWalletID(c *fiber.Ctx) error <span class="cov0" title="0">{
        page, limit, err := api.GetPageAndLimit(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">walletId := c.Params("walletId")
        exchangeRates, err := h.services.ExchangeRate.GetExchangeRatesByWalletID(c.Context(), walletId, page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(api.NewSuccessResponse(exchangeRates))</span>
}

// UpdateExchangeRate updates an exchange rate
// @Summary Update an exchange rate
// @Description Update an exchange rate based on the provided request
// @Tags Exchange Rate
// @Accept json
// @Produce json
// @Param exchangeRateId path string true "Exchange Rate ID"
// @Param exchangeRate body object true "Update Exchange Rate Request"
// @Success 200 {object} api.SuccessResponse{result=model.ExchangeRate}
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/exchange-rates/{exchangeRateId} [put]
func (h *exchangeRateHandler) UpdateExchangeRate(c *fiber.Ctx) error <span class="cov0" title="0">{
        exchangeRateId := c.Params("exchangeRateId")
        var req struct {
                ExchangeRate decimal.Decimal `json:"exchangeRate" validate:"required"`
        }
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(c.Context()).Error("Invalid body request", logger.Field("error", err))
                return errs.NewBadRequestError("Invalid body request", "INVALID_BODY_REQUEST", err)
        }</span>
        <span class="cov0" title="0">exchangeRate, err := h.services.ExchangeRate.UpdateExchangeRate(c.Context(), exchangeRateId, req.ExchangeRate)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(api.NewSuccessResponse(exchangeRate))</span>
}

// DeleteExchangeRate deletes an exchange rate
// @Summary Delete an exchange rate
// @Description Delete an exchange rate by its ID
// @Tags Exchange Rate
// @Produce json
// @Param exchangeRateId path string true "Exchange Rate ID"
// @Success 202 {object} api.SuccessResponse
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/exchange-rates/{exchangeRateId} [delete]
func (h *exchangeRateHandler) DeleteExchangeRate(c *fiber.Ctx) error <span class="cov0" title="0">{
        exchangeRateId := c.Params("exchangeRateId")
        err := h.services.ExchangeRate.DeleteExchangeRate(c.Context(), exchangeRateId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusAccepted).JSON(api.NewSuccessResponse(nil))</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package backofficev1

import (
        "github.com/abdelrahman146/digital-wallet/internal/service"
        "github.com/abdelrahman146/digital-wallet/pkg/api"
        "github.com/abdelrahman146/digital-wallet/pkg/errs"
        "github.com/gofiber/fiber/v2"
        "strconv"
)

type programHandler struct {
        services *service.Services
}

func NewProgramHandler(appGroup fiber.Router, services *service.Services) <span class="cov0" title="0">{
        handler := &amp;programHandler{services: services}
        handler.Setup(appGroup)
}</span>

func (h *programHandler) Setup(appGroup fiber.Router) <span class="cov0" title="0">{
        group := appGroup.Group("programs")
        group.Post("/", h.CreateProgram)
        group.Patch("/:programId", h.UpdateProgram)
        group.Delete("/:programId", h.DeleteProgram)
        group.Get("/:programId", h.GetProgram)
        group.Get("/", h.GetPrograms)
}</span>

// CreateProgram creates a new program
// @Summary Create a new program
// @Description Create a program based on the provided request
// @Tags Program
// @Accept json
// @Produce json
// @Param program body service.CreateProgramRequest true "Create Program Request"
// @Success 201 {object} api.SuccessResponse{result=model.Program}
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/programs [post]
func (h *programHandler) CreateProgram(c *fiber.Ctx) error <span class="cov0" title="0">{
        var req service.CreateProgramRequest
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                return errs.NewBadRequestError("Invalid body request", "INVALID_BODY_REQUEST", err)
        }</span>
        <span class="cov0" title="0">program, err := h.services.Program.CreateProgram(c.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusCreated).JSON(api.NewSuccessResponse(program))</span>
}

// UpdateProgram updates a program
// @Summary Update a program
// @Description Update a program based on the provided request
// @Tags Program
// @Accept json
// @Produce json
// @Param programId path string true "Program ID"
// @Param program body service.UpdateProgramRequest true "Update Program Request"
// @Success 200 {object} api.SuccessResponse{result=model.Program}
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/programs/{programId} [patch]
func (h *programHandler) UpdateProgram(c *fiber.Ctx) error <span class="cov0" title="0">{
        programID, err := strconv.ParseUint(c.Params("programId"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return errs.NewBadRequestError("Invalid program ID", "INVALID_PROGRAM_ID", err)
        }</span>
        <span class="cov0" title="0">var req service.UpdateProgramRequest
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                return errs.NewBadRequestError("Invalid body request", "INVALID_BODY_REQUEST", err)
        }</span>
        <span class="cov0" title="0">program, err := h.services.Program.UpdateProgram(c.Context(), programID, req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusAccepted).JSON(api.NewSuccessResponse(program))</span>
}

// DeleteProgram deletes a program
// @Summary Delete a program
// @Description Delete a program based on the provided request
// @Tags Program
// @Param programId path string true "Program ID"
// @Success 204
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/programs/{programId} [delete]
func (h *programHandler) DeleteProgram(c *fiber.Ctx) error <span class="cov0" title="0">{
        programID, err := strconv.ParseUint(c.Params("programId"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return errs.NewBadRequestError("Invalid program ID", "INVALID_PROGRAM_ID", err)
        }</span>
        <span class="cov0" title="0">err = h.services.Program.DeleteProgram(c.Context(), programID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusAccepted).JSON(api.NewSuccessResponse(nil))</span>
}

// GetProgram retrieves a program
// @Summary Get a program
// @Description Get a program based on the provided request
// @Tags Program
// @Param programId path string true "Program ID"
// @Success 200 {object} api.SuccessResponse{result=model.Program}
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/programs/{programId} [get]
func (h *programHandler) GetProgram(c *fiber.Ctx) error <span class="cov0" title="0">{
        programID, err := strconv.ParseUint(c.Params("programId"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return errs.NewBadRequestError("Invalid program ID", "INVALID_PROGRAM_ID", err)
        }</span>
        <span class="cov0" title="0">program, err := h.services.Program.GetProgram(c.Context(), programID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(api.NewSuccessResponse(program))</span>
}

// GetPrograms retrieves a list of programs
// @Summary Get a list of programs
// @Description Get a list of programs based on the provided request
// @Tags Program
// @Param page query int false "Page"
// @Param limit query int false "Limit"
// @Success 200 {object} api.SuccessResponse{result=api.List[model.Program]}
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/programs [get]
func (h *programHandler) GetPrograms(c *fiber.Ctx) error <span class="cov0" title="0">{
        page, limit, err := api.GetPageAndLimit(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">programs, err := h.services.Program.ListPrograms(c.Context(), page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(api.NewSuccessResponse(programs))</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package backofficev1

import (
        "github.com/abdelrahman146/digital-wallet/internal/service"
        "github.com/abdelrahman146/digital-wallet/pkg/api"
        "github.com/gofiber/fiber/v2"
)

func New(app *fiber.App, services *service.Services) <span class="cov0" title="0">{
        group := app.Group("api/v1/backoffice/")
        group.Use(api.AdminAuthenticationMiddleware())
        group.Use(api.CreateAppContext(api.AppActorAdmin))
        NewAuditHandler(group, services)
        NewAccountHandler(group, services)
        NewExchangeRateHandler(group, services)
        NewTierHandler(group, services)
        NewUserHandler(group, services)
        NewWalletHandler(group, services)
        NewTransactionHandler(group, services)
        NewTriggerHandler(group, services)
        NewProgramHandler(group, services)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package backofficev1

import (
        "github.com/abdelrahman146/digital-wallet/internal/service"
        "github.com/abdelrahman146/digital-wallet/pkg/api"
        "github.com/abdelrahman146/digital-wallet/pkg/errs"
        "github.com/abdelrahman146/digital-wallet/pkg/logger"
        "github.com/gofiber/fiber/v2"
)

type tierHandler struct {
        services *service.Services
}

func NewTierHandler(appGroup fiber.Router, services *service.Services) <span class="cov0" title="0">{
        handler := &amp;tierHandler{services: services}
        handler.Setup(appGroup)
}</span>

func (h *tierHandler) Setup(appGroup fiber.Router) <span class="cov0" title="0">{
        group := appGroup.Group("tiers")
        group.Post("/", h.CreateTier)
        group.Get("/", h.GetTiers)
        group.Get("/:tierId", h.GetTierByID)
        group.Delete("/:tierId", h.DeleteTier)
}</span>

func (h *tierHandler) CreateTier(c *fiber.Ctx) error <span class="cov0" title="0">{
        var req service.CreateTierRequest
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(c.Context()).Error("Invalid body request", logger.Field("error", err))
                return errs.NewBadRequestError("Invalid body request", "INVALID_BODY_REQUEST", err)
        }</span>
        <span class="cov0" title="0">tier, err := h.services.Tier.CreateTier(c.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusCreated).JSON(api.NewSuccessResponse(tier))</span>
}

func (h *tierHandler) GetTierByID(c *fiber.Ctx) error <span class="cov0" title="0">{
        id := c.Params("tierId")
        tier, err := h.services.Tier.GetTierByID(c.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(api.NewSuccessResponse(tier))</span>
}

func (h *tierHandler) GetTiers(c *fiber.Ctx) error <span class="cov0" title="0">{
        page, limit, err := api.GetPageAndLimit(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">tiers, err := h.services.Tier.GetTiers(c.Context(), page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(api.NewSuccessResponse(tiers))</span>
}

func (h *tierHandler) DeleteTier(c *fiber.Ctx) error <span class="cov0" title="0">{
        id := c.Params("tierId")
        err := h.services.Tier.DeleteTier(c.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusAccepted).JSON(api.NewSuccessResponse(nil))</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package backofficev1

import (
        "github.com/abdelrahman146/digital-wallet/internal/service"
        "github.com/abdelrahman146/digital-wallet/pkg/api"
        "github.com/abdelrahman146/digital-wallet/pkg/errs"
        "github.com/abdelrahman146/digital-wallet/pkg/logger"
        "github.com/abdelrahman146/digital-wallet/pkg/validator"
        "github.com/gofiber/fiber/v2"
)

type transactionHandler struct {
        services *service.Services
}

func NewTransactionHandler(appGroup fiber.Router, services *service.Services) <span class="cov0" title="0">{
        handler := &amp;transactionHandler{
                services: services,
        }
        handler.Setup(appGroup)
}</span>

func (h *transactionHandler) Setup(appGroup fiber.Router) <span class="cov0" title="0">{
        group := appGroup.Group("wallets/:walletId/transactions")
        group.Post("/", h.CreateTransaction)
        group.Post("/exchange", h.CreateExchangeTransaction)
        group.Get("/", h.GetTransactions)
        group.Get("/sum", h.GetTransactionsSum)
}</span>

// GetTransactions retrieves all transactions of a wallet
// @Summary Get all transactions of a wallet
// @Description Get all transactions of a wallet
// @Tags Transaction
// @Param walletId path string true "Wallet ID"
// @Param page query int false "Page"
// @Param limit query int false "Limit"
// @Success 200 {object} api.SuccessResponse{result=[]model.Transaction}
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/wallets/{walletId}/transactions [get]
func (h *transactionHandler) GetTransactions(c *fiber.Ctx) error <span class="cov0" title="0">{
        page, limit, err := api.GetPageAndLimit(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">walletId := c.Params("walletId")
        transactions, err := h.services.Transaction.GetWalletTransactions(c.Context(), walletId, page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(api.NewSuccessResponse(transactions))</span>
}

// GetTransactionsSum retrieves the sum of all transactions of a wallet
// @Summary Get the sum of all transactions of a wallet
// @Description Get the sum of all transactions of a wallet
// @Tags Transaction
// @Param walletId path string true "Wallet ID"
// @Success 200 {object} api.SuccessResponse{result=uint64}
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/wallets/{walletId}/transactions/sum [get]
func (h *transactionHandler) GetTransactionsSum(c *fiber.Ctx) error <span class="cov0" title="0">{
        walletId := c.Params("walletId")
        sum, err := h.services.Transaction.GetWalletTransactionSum(c.Context(), walletId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(api.NewSuccessResponse(sum))</span>
}

// CreateTransaction creates a transaction
// @Summary Create a transaction
// @Description Create a transaction based on the provided request
// @Tags Transaction
// @Accept json
// @Param walletId path string true "Wallet ID"
// @Param req body object true "Create Transaction Request"
// @Success 201 {object} api.SuccessResponse{result=model.Transaction}
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/wallets/{walletId}/transactions [post]
func (h *transactionHandler) CreateTransaction(c *fiber.Ctx) error <span class="cov0" title="0">{
        walletId := c.Params("walletId")
        var req struct {
                service.TransactionRequest
                AccountId string `json:"accountId,omitempty" validate:"required"`
        }
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(c.Context()).Error("Invalid body request", logger.Field("error", err))
                return errs.NewBadRequestError("Invalid body request", "INVALID_BODY_REQUEST", err)
        }</span>
        <span class="cov0" title="0">transaction, err := h.services.Transaction.CreateTransaction(c.Context(), walletId, req.AccountId, &amp;req.TransactionRequest)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusCreated).JSON(api.NewSuccessResponse(transaction))</span>
}

// CreateExchangeTransaction creates an exchange transaction
// @Summary Create an exchange transaction
// @Description Create an exchange transaction based on the provided request
// @Tags Transaction
// @Accept json
// @Param req body object true "Create Exchange Transaction Request"
// @Success 200 {object} api.SuccessResponse{result=service.ExchangeResponse}
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/wallets/{walletId}/transactions/exchange [post]
func (h *transactionHandler) CreateExchangeTransaction(c *fiber.Ctx) error <span class="cov0" title="0">{
        var req struct {
                FromWalletID string `json:"fromWalletId,omitempty" validate:"required"`
                ToWalletID   string `json:"toWalletId,omitempty" validate:"required"`
                UserID       string `json:"userId,omitempty" validate:"required"`
                Amount       uint64 `json:"amount,omitempty" validate:"required,gt=0"`
        }
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(c.Context()).Error("Invalid body request", logger.Field("error", err))
                return errs.NewBadRequestError("Invalid body request", "INVALID_BODY_REQUEST", err)
        }</span>
        // Validate request
        <span class="cov0" title="0">if err := validator.GetValidator().ValidateStruct(req); err != nil </span><span class="cov0" title="0">{
                fields := validator.GetValidator().GetValidationErrors(err)
                api.GetLogger(c.Context()).Error("Invalid request", logger.Field("fields", fields))
                return errs.NewValidationError("Invalid request", "", fields)
        }</span>

        <span class="cov0" title="0">exchangeResponse, err := h.services.Transaction.Exchange(c.Context(), req.FromWalletID, req.ToWalletID, req.UserID, req.Amount)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(api.NewSuccessResponse(exchangeResponse))</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package backofficev1

import (
        "github.com/abdelrahman146/digital-wallet/internal/service"
        "github.com/abdelrahman146/digital-wallet/pkg/api"
        "github.com/abdelrahman146/digital-wallet/pkg/errs"
        "github.com/abdelrahman146/digital-wallet/pkg/logger"
        "github.com/gofiber/fiber/v2"
        "strconv"
)

type triggerHandler struct {
        services *service.Services
}

func NewTriggerHandler(appGroup fiber.Router, services *service.Services) <span class="cov0" title="0">{
        handler := &amp;triggerHandler{services: services}
        handler.Setup(appGroup)
}</span>

func (h *triggerHandler) Setup(appGroup fiber.Router) <span class="cov0" title="0">{
        group := appGroup.Group("triggers")
        group.Post("/", h.CreateTrigger)
        group.Put("/:triggerId", h.UpdateTrigger)
        group.Delete("/:triggerId", h.DeleteTrigger)
        group.Get("/:triggerId", h.GetTrigger)
        group.Get("/", h.GetTriggers)
}</span>

// CreateTrigger creates a new trigger
// @Summary Create a new trigger
// @Description Create a trigger based on the provided request
// @Tags Trigger
// @Accept json
// @Produce json
// @Param trigger body service.CreateTriggerRequest true "Create Trigger Request"
// @Success 201 {object} api.SuccessResponse{result=model.Trigger}
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/triggers [post]
func (h *triggerHandler) CreateTrigger(c *fiber.Ctx) error <span class="cov0" title="0">{
        var req service.CreateTriggerRequest
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(c.Context()).Error("Invalid body request")
                return errs.NewBadRequestError("Invalid body request", "INVALID_BODY_REQUEST", err)
        }</span>
        <span class="cov0" title="0">trigger, err := h.services.Trigger.CreateTrigger(c.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusCreated).JSON(api.NewSuccessResponse(trigger))</span>
}

// UpdateTrigger updates a trigger
// @Summary Update a trigger
// @Description Update a trigger based on the provided request
// @Tags Trigger
// @Accept json
// @Produce json
// @Param triggerId path string true "Trigger ID"
// @Param trigger body service.UpdateTriggerRequest true "Update Trigger Request"
// @Success 200 {object} api.SuccessResponse{result=model.Trigger}
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/triggers/{triggerId} [put]
func (h *triggerHandler) UpdateTrigger(c *fiber.Ctx) error <span class="cov0" title="0">{
        id, err := strconv.ParseUint(c.Params("triggerId"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(c.Context()).Error("Invalid trigger ID", logger.Field("triggerId", c.Params("triggerId")))
                return errs.NewBadRequestError("Invalid trigger ID", "INVALID_TRIGGER_ID", err)
        }</span>
        <span class="cov0" title="0">var req service.UpdateTriggerRequest
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(c.Context()).Error("Invalid body request")
                return errs.NewBadRequestError("Invalid body request", "INVALID_BODY_REQUEST", err)
        }</span>
        <span class="cov0" title="0">trigger, err := h.services.Trigger.UpdateTrigger(c.Context(), id, req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(api.NewSuccessResponse(trigger))</span>
}

// DeleteTrigger deletes a trigger
// @Summary Delete a trigger
// @Description Delete a trigger based on the provided request
// @Tags Trigger
// @Param triggerId path string true "Trigger ID"
// @Success 202 {object} api.SuccessResponse
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/triggers/{triggerId} [delete]
func (h *triggerHandler) DeleteTrigger(c *fiber.Ctx) error <span class="cov0" title="0">{
        id, err := strconv.ParseUint(c.Params("triggerId"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(c.Context()).Error("Invalid trigger ID", logger.Field("triggerId", c.Params("triggerId")))
                return errs.NewBadRequestError("Invalid trigger ID", "INVALID_TRIGGER_ID", err)
        }</span>
        <span class="cov0" title="0">err = h.services.Trigger.DeleteTrigger(c.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusAccepted).JSON(api.NewSuccessResponse(nil))</span>
}

// GetTrigger retrieves a trigger by its ID
// @Summary Get a trigger by its ID
// @Description Get a trigger by its ID
// @Tags Trigger
// @Param triggerId path string true "Trigger ID"
// @Success 200 {object} api.SuccessResponse{result=model.Trigger}
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/triggers/{triggerId} [get]
func (h *triggerHandler) GetTrigger(c *fiber.Ctx) error <span class="cov0" title="0">{
        id, err := strconv.ParseUint(c.Params("triggerId"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(c.Context()).Error("Invalid trigger ID", logger.Field("triggerId", c.Params("triggerId")))
                return errs.NewBadRequestError("Invalid trigger ID", "INVALID_TRIGGER_ID", err)
        }</span>
        <span class="cov0" title="0">trigger, err := h.services.Trigger.GetTrigger(c.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(api.NewSuccessResponse(trigger))</span>
}

// GetTriggers retrieves a list of triggers
// @Summary Get a list of triggers
// @Description Get a list of triggers
// @Tags Trigger
// @Produce json
// @Param page query int false "Page"
// @Param limit query int false "Limit"
// @Success 200 {object} api.SuccessResponse{result=[]model.Trigger}
// @Failure 400 {object} api.ErrorResponse
func (h *triggerHandler) GetTriggers(c *fiber.Ctx) error <span class="cov0" title="0">{
        page, limit, err := api.GetPageAndLimit(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">triggers, err := h.services.Trigger.ListTriggers(c.Context(), page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(api.NewSuccessResponse(triggers))</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package backofficev1

import (
        "github.com/abdelrahman146/digital-wallet/internal/service"
        "github.com/abdelrahman146/digital-wallet/pkg/api"
        "github.com/gofiber/fiber/v2"
)

type userHandler struct {
        services *service.Services
}

func NewUserHandler(appGroup fiber.Router, services *service.Services) <span class="cov0" title="0">{
        handler := &amp;userHandler{services: services}
        handler.Setup(appGroup)
}</span>

func (h *userHandler) Setup(appGroup fiber.Router) <span class="cov0" title="0">{
        group := appGroup.Group("/users")
        group.Post("/", h.CreateUser)
        group.Get("/", h.GetUsers)
        group.Get("/:userId", h.GetUserByID)
        group.Put("/:userId/tier", h.SetUserTier)
        group.Delete("/:userId", h.DeleteUser)
}</span>

// CreateUser creates a new user
// @Summary Create a new user
// @Description Create a user based on the provided request
// @Tags User
// @Accept json
// @Produce json
// @Param user body service.CreateUserRequest true "Create User Request"
// @Success 201 {object} api.SuccessResponse{result=model.User}
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/users [post]
func (h *userHandler) CreateUser(c *fiber.Ctx) error <span class="cov0" title="0">{
        var req service.CreateUserRequest
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">user, err := h.services.User.CreateUser(c.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusCreated).JSON(api.NewSuccessResponse(user))</span>
}

// GetUserByID retrieves a user by its ID
// @Summary Get a user by its ID
// @Description Get a user by its ID
// @Tags User
// @Param userId path string true "User ID"
// @Success 200 {object} api.SuccessResponse{result=model.User}
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/users/{userId} [get]
func (h *userHandler) GetUserByID(c *fiber.Ctx) error <span class="cov0" title="0">{
        userId := c.Params("userId")
        user, err := h.services.User.GetUserByID(c.Context(), userId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(api.NewSuccessResponse(user))</span>
}

// SetUserTier sets the tier of a user
// @Summary Set the tier of a user
// @Description Set the tier of a user
// @Tags User
// @Param userId path string true "User ID"
// @Param tierId path string true "Tier ID"
// @Success 202 {object} api.SuccessResponse{result=model.User}
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/users/{userId}/tier/{tierId} [put]
func (h *userHandler) SetUserTier(c *fiber.Ctx) error <span class="cov0" title="0">{
        userId := c.Params("userId")
        tierId := c.Params("tierId")
        user, err := h.services.User.SetUserTier(c.Context(), userId, tierId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusAccepted).JSON(api.NewSuccessResponse(user))</span>
}

// GetUsers retrieves a list of users
// @Summary Get a list of users
// @Description Get a list of users
// @Tags User
// @Param page query int false "Page"
// @Param limit query int false "Limit"
// @Success 200 {object} api.SuccessResponse{result=[]model.User}
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/users [get]
func (h *userHandler) GetUsers(c *fiber.Ctx) error <span class="cov0" title="0">{
        page, limit, err := api.GetPageAndLimit(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">users, err := h.services.User.GetUsers(c.Context(), page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(api.NewSuccessResponse(users))</span>
}

// DeleteUser deletes a user
// @Summary Delete a user
// @Description Delete a user
// @Tags User
// @Param userId path string true "User ID"
// @Success 202 {object} api.SuccessResponse
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/users/{userId} [delete]
func (h *userHandler) DeleteUser(c *fiber.Ctx) error <span class="cov0" title="0">{
        userId := c.Params("userId")
        err := h.services.User.DeleteUser(c.Context(), userId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusAccepted).JSON(api.NewSuccessResponse(nil))</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package backofficev1

import (
        "github.com/abdelrahman146/digital-wallet/internal/service"
        "github.com/abdelrahman146/digital-wallet/pkg/api"
        "github.com/abdelrahman146/digital-wallet/pkg/errs"
        "github.com/abdelrahman146/digital-wallet/pkg/logger"
        "github.com/gofiber/fiber/v2"
        "math"
)

type walletHandler struct {
        services *service.Services
}

func NewWalletHandler(appGroup fiber.Router, services *service.Services) <span class="cov0" title="0">{
        handler := &amp;walletHandler{
                services: services,
        }
        handler.Setup(appGroup)
}</span>

func (h *walletHandler) Setup(appGroup fiber.Router) <span class="cov0" title="0">{
        group := appGroup.Group("wallets")
        group.Post("/", h.CreateWallet)
        group.Get("/", h.GetWallets)
        group.Get("/:walletId/check-integrity", h.CheckWalletIntegrity)
        group.Get("/:walletId", h.GetWalletByID)
        group.Put("/:walletId", h.UpdateWallet)
        group.Delete("/:walletId", h.DeleteWallet)

}</span>

// CreateWallet creates a new wallet
// @Summary Create a new wallet
// @Description Create a wallet based on the provided request
// @Tags Wallet
// @Accept json
// @Produce json
// @Param wallet body service.CreateWalletRequest true "Create Wallet Request"
// @Success 201 {object} api.SuccessResponse{result=model.Wallet}
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/wallets [post]
func (h *walletHandler) CreateWallet(c *fiber.Ctx) error <span class="cov0" title="0">{
        var req service.CreateWalletRequest
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(c.Context()).Error("Invalid body request", logger.Field("error", err))
                return errs.NewBadRequestError("Invalid body request", "INVALID_BODY_REQUEST", err)
        }</span>
        <span class="cov0" title="0">wallet, err := h.services.Wallet.CreateWallet(c.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusCreated).JSON(api.NewSuccessResponse(wallet))</span>
}

// GetWalletByID retrieves a wallet by its ID
// @Summary Get a wallet by its ID
// @Description Get a wallet by its ID
// @Tags Wallet
// @Produce json
// @Param walletId path string true "Wallet ID"
// @Success 200 {object} api.SuccessResponse{result=model.Wallet}
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/wallets/{walletId} [get]
func (h *walletHandler) GetWalletByID(c *fiber.Ctx) error <span class="cov0" title="0">{
        id := c.Params("walletId")
        wallet, err := h.services.Wallet.GetWalletByID(c.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(api.NewSuccessResponse(wallet))</span>
}

// GetWallets retrieves a list of wallets
// @Summary Get a list of wallets
// @Description Get a list of wallets
// @Tags Wallet
// @Produce json
// @Param page query int false "Page"
// @Param limit query int false "Limit"
// @Success 200 {object} api.SuccessResponse{result=[]model.Wallet}
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/wallets [get]
func (h *walletHandler) GetWallets(c *fiber.Ctx) error <span class="cov0" title="0">{
        page, limit, err := api.GetPageAndLimit(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">wallets, err := h.services.Wallet.GetWallets(c.Context(), page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(api.NewSuccessResponse(wallets))</span>
}

// UpdateWallet updates a wallet
// @Summary Update a wallet
// @Description Update a wallet based on the provided request
// @Tags Wallet
// @Accept json
// @Produce json
// @Param walletId path string true "Wallet ID"
// @Param wallet body service.UpdateWalletRequest true "Update Wallet Request"
// @Success 202 {object} api.SuccessResponse{result=model.Wallet}
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/wallets/{walletId} [put]
func (h *walletHandler) UpdateWallet(c *fiber.Ctx) error <span class="cov0" title="0">{
        id := c.Params("walletId")
        var req service.UpdateWalletRequest
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(c.Context()).Error("Invalid body request", logger.Field("error", err))
                return errs.NewBadRequestError("Invalid body request", "INVALID_BODY_REQUEST", err)
        }</span>
        <span class="cov0" title="0">wallet, err := h.services.Wallet.UpdateWallet(c.Context(), id, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusAccepted).JSON(api.NewSuccessResponse(wallet))</span>
}

// DeleteWallet deletes a wallet
// @Summary Delete a wallet
// @Description Delete a wallet by its ID
// @Tags Wallet
// @Produce json
// @Param walletId path string true "Wallet ID"
// @Success 202 {object} api.SuccessResponse
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/wallets/{walletId} [delete]
func (h *walletHandler) DeleteWallet(c *fiber.Ctx) error <span class="cov0" title="0">{
        id := c.Params("walletId")
        err := h.services.Wallet.DeleteWallet(c.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusAccepted).JSON(api.NewSuccessResponse(nil))</span>
}

// CheckWalletIntegrity checks the integrity of a wallet
// @Summary Check the integrity of a wallet
// @Description Check the integrity of a wallet by comparing the sum of accounts and transactions
// @Tags Wallet
// @Produce json
// @Param walletId path string true "Wallet ID"
// @Success 200 {object} api.SuccessResponse{result=map[string]interface{}}
// @Failure 400 {object} api.ErrorResponse
// @Router /backoffice/wallets/{walletId}/check-integrity [get]
func (h *walletHandler) CheckWalletIntegrity(c *fiber.Ctx) error <span class="cov0" title="0">{
        id := c.Params("walletId")
        accountsSum, err := h.services.Wallet.GetAccountsSum(c.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">transactionsSum, err := h.services.Wallet.GetTransactionsSum(c.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">diff := math.Abs(float64(accountsSum - transactionsSum))
        return c.Status(fiber.StatusOK).JSON(api.NewSuccessResponse(fiber.Map{
                "accountsSum":     accountsSum,
                "transactionsSum": transactionsSum,
                "diff":            diff,
        }))</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package main

func main() {<span class="cov0" title="0">

}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://swagger.io/terms/",
        "contact": {
            "name": "Abdel Rahman Hussein",
            "url": "https://github.com/abdelrahman146"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/backoffice/audit/actor/{actor}/{actorId}": {
            "get": {
                "description": "Get all audit logs of an actor",
                "tags": [
                    "Audit"
                ],
                "summary": "Get all audit logs of an actor",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Actor",
                        "name": "actor",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Actor ID",
                        "name": "actorId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "Page",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Limit",
                        "name": "limit",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/api.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "result": {
                                            "type": "array",
                                            "items": {
                                                "$ref": "#/definitions/model.Audit"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/backoffice/audit/record/{table}/{recordId}": {
            "get": {
                "description": "Get all audit logs of a record",
                "tags": [
                    "Audit"
                ],
                "summary": "Get all audit logs of a record",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Table",
                        "name": "table",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Record ID",
                        "name": "recordId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "Page",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Limit",
                        "name": "limit",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/api.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "result": {
                                            "type": "array",
                                            "items": {
                                                "$ref": "#/definitions/model.Audit"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/backoffice/audit/table/{table}": {
            "get": {
                "description": "Get all audit logs of a table",
                "tags": [
                    "Audit"
                ],
                "summary": "Get all audit logs of a table",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Table",
                        "name": "table",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "Page",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Limit",
                        "name": "limit",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/api.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "result": {
                                            "type": "array",
                                            "items": {
                                                "$ref": "#/definitions/model.Audit"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/backoffice/exchange-rates": {
            "get": {
                "description": "Get all exchange rates",
                "tags": [
                    "Exchange Rate"
                ],
                "summary": "Get all exchange rates",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Page",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Limit",
                        "name": "limit",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/api.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "result": {
                                            "type": "array",
                                            "items": {
                                                "$ref": "#/definitions/model.ExchangeRate"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            },
            "post": {
                "description": "Create an exchange rate based on the provided request",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Exchange Rate"
                ],
                "summary": "Create a new exchange rate",
                "parameters": [
                    {
                        "description": "Create Exchange Rate Request",
                        "name": "exchangeRate",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/service.CreateExchangeRateRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/api.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "result": {
                                            "$ref": "#/definitions/model.ExchangeRate"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/backoffice/exchange-rates/wallets/{walletId}": {
            "get": {
                "description": "Get all exchange rates of a wallet",
                "tags": [
                    "Exchange Rate"
                ],
                "summary": "Get all exchange rates of a wallet",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Wallet ID",
                        "name": "walletId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "Page",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Limit",
                        "name": "limit",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/api.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "result": {
                                            "type": "array",
                                            "items": {
                                                "$ref": "#/definitions/model.ExchangeRate"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/backoffice/exchange-rates/{exchangeRateId}": {
            "put": {
                "description": "Update an exchange rate based on the provided request",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Exchange Rate"
                ],
                "summary": "Update an exchange rate",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Exchange Rate ID",
                        "name": "exchangeRateId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Update Exchange Rate Request",
                        "name": "exchangeRate",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/api.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "result": {
                                            "$ref": "#/definitions/model.ExchangeRate"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            },
            "delete": {
                "description": "Delete an exchange rate by its ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Exchange Rate"
                ],
                "summary": "Delete an exchange rate",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Exchange Rate ID",
                        "name": "exchangeRateId",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Accepted",
                        "schema": {
                            "$ref": "#/definitions/api.SuccessResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/backoffice/programs": {
            "get": {
                "description": "Get a list of programs based on the provided request",
                "tags": [
                    "Program"
                ],
                "summary": "Get a list of programs",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Page",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Limit",
                        "name": "limit",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/api.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "result": {
                                            "$ref": "#/definitions/api.List-model_Program"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            },
            "post": {
                "description": "Create a program based on the provided request",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Program"
                ],
                "summary": "Create a new program",
                "parameters": [
                    {
                        "description": "Create Program Request",
                        "name": "program",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/service.CreateProgramRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/api.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "result": {
                                            "$ref": "#/definitions/model.Program"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/backoffice/programs/{programId}": {
            "get": {
                "description": "Get a program based on the provided request",
                "tags": [
                    "Program"
                ],
                "summary": "Get a program",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Program ID",
                        "name": "programId",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/api.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "result": {
                                            "$ref": "#/definitions/model.Program"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            },
            "delete": {
                "description": "Delete a program based on the provided request",
                "tags": [
                    "Program"
                ],
                "summary": "Delete a program",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Program ID",
                        "name": "programId",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            },
            "patch": {
                "description": "Update a program based on the provided request",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Program"
                ],
                "summary": "Update a program",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Program ID",
                        "name": "programId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Update Program Request",
                        "name": "program",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/service.UpdateProgramRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/api.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "result": {
                                            "$ref": "#/definitions/model.Program"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/backoffice/triggers": {
            "post": {
                "description": "Create a trigger based on the provided request",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Trigger"
                ],
                "summary": "Create a new trigger",
                "parameters": [
                    {
                        "description": "Create Trigger Request",
                        "name": "trigger",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/service.CreateTriggerRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/api.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "result": {
                                            "$ref": "#/definitions/model.Trigger"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/backoffice/triggers/{triggerId}": {
            "get": {
                "description": "Get a trigger by its ID",
                "tags": [
                    "Trigger"
                ],
                "summary": "Get a trigger by its ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Trigger ID",
                        "name": "triggerId",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/api.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "result": {
                                            "$ref": "#/definitions/model.Trigger"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            },
            "put": {
                "description": "Update a trigger based on the provided request",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Trigger"
                ],
                "summary": "Update a trigger",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Trigger ID",
                        "name": "triggerId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Update Trigger Request",
                        "name": "trigger",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/service.UpdateTriggerRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/api.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "result": {
                                            "$ref": "#/definitions/model.Trigger"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            },
            "delete": {
                "description": "Delete a trigger based on the provided request",
                "tags": [
                    "Trigger"
                ],
                "summary": "Delete a trigger",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Trigger ID",
                        "name": "triggerId",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Accepted",
                        "schema": {
                            "$ref": "#/definitions/api.SuccessResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/backoffice/users": {
            "get": {
                "description": "Get a list of users",
                "tags": [
                    "User"
                ],
                "summary": "Get a list of users",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Page",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Limit",
                        "name": "limit",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/api.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "result": {
                                            "type": "array",
                                            "items": {
                                                "$ref": "#/definitions/model.User"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            },
            "post": {
                "description": "Create a user based on the provided request",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Create a new user",
                "parameters": [
                    {
                        "description": "Create User Request",
                        "name": "user",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/service.CreateUserRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/api.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "result": {
                                            "$ref": "#/definitions/model.User"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/backoffice/users/{userId}": {
            "get": {
                "description": "Get a user by its ID",
                "tags": [
                    "User"
                ],
                "summary": "Get a user by its ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User ID",
                        "name": "userId",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/api.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "result": {
                                            "$ref": "#/definitions/model.User"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            },
            "delete": {
                "description": "Delete a user",
                "tags": [
                    "User"
                ],
                "summary": "Delete a user",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User ID",
                        "name": "userId",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Accepted",
                        "schema": {
                            "$ref": "#/definitions/api.SuccessResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/backoffice/users/{userId}/tier/{tierId}": {
            "put": {
                "description": "Set the tier of a user",
                "tags": [
                    "User"
                ],
                "summary": "Set the tier of a user",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User ID",
                        "name": "userId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Tier ID",
                        "name": "tierId",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Accepted",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/api.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "result": {
                                            "$ref": "#/definitions/model.User"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/backoffice/wallets": {
            "get": {
                "description": "Get a list of wallets",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Wallet"
                ],
                "summary": "Get a list of wallets",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Page",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Limit",
                        "name": "limit",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/api.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "result": {
                                            "type": "array",
                                            "items": {
                                                "$ref": "#/definitions/model.Wallet"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            },
            "post": {
                "description": "Create a wallet based on the provided request",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Wallet"
                ],
                "summary": "Create a new wallet",
                "parameters": [
                    {
                        "description": "Create Wallet Request",
                        "name": "wallet",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/service.CreateWalletRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/api.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "result": {
                                            "$ref": "#/definitions/model.Wallet"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/backoffice/wallets/{walletId}": {
            "get": {
                "description": "Get a wallet by its ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Wallet"
                ],
                "summary": "Get a wallet by its ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Wallet ID",
                        "name": "walletId",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/api.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "result": {
                                            "$ref": "#/definitions/model.Wallet"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            },
            "put": {
                "description": "Update a wallet based on the provided request",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Wallet"
                ],
                "summary": "Update a wallet",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Wallet ID",
                        "name": "walletId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Update Wallet Request",
                        "name": "wallet",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/service.UpdateWalletRequest"
                        }
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Accepted",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/api.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "result": {
                                            "$ref": "#/definitions/model.Wallet"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            },
            "delete": {
                "description": "Delete a wallet by its ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Wallet"
                ],
                "summary": "Delete a wallet",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Wallet ID",
                        "name": "walletId",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Accepted",
                        "schema": {
                            "$ref": "#/definitions/api.SuccessResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/backoffice/wallets/{walletId}/accounts": {
            "get": {
                "description": "Get all accounts of a wallet",
                "tags": [
                    "Account"
                ],
                "summary": "Get all accounts of a wallet",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Wallet ID",
                        "name": "walletId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "Page",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Limit",
                        "name": "limit",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/api.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "result": {
                                            "type": "array",
                                            "items": {
                                                "$ref": "#/definitions/model.Account"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            },
            "post": {
                "description": "Create an account based on the provided request",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Account"
                ],
                "summary": "Create an account",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Wallet ID",
                        "name": "walletId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Create Account Request",
                        "name": "account",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/api.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "result": {
                                            "$ref": "#/definitions/model.Account"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/backoffice/wallets/{walletId}/accounts/sum": {
            "get": {
                "description": "Get the sum of all accounts of a wallet",
                "tags": [
                    "Account"
                ],
                "summary": "Get the sum of all accounts of a wallet",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Wallet ID",
                        "name": "walletId",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/api.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "result": {
                                            "type": "number"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/backoffice/wallets/{walletId}/accounts/{accountId}": {
            "get": {
                "description": "Get an account by its ID",
                "tags": [
                    "Account"
                ],
                "summary": "Get an account by its ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Wallet ID",
                        "name": "walletId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Account ID",
                        "name": "accountId",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/api.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "result": {
                                            "$ref": "#/definitions/model.Account"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            },
            "delete": {
                "description": "Delete an account",
                "tags": [
                    "Account"
                ],
                "summary": "Delete an account",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Wallet ID",
                        "name": "walletId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Account ID",
                        "name": "accountId",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Accepted",
                        "schema": {
                            "$ref": "#/definitions/api.SuccessResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/backoffice/wallets/{walletId}/accounts/{accountId}/transactions": {
            "get": {
                "description": "Get all transactions of an account",
                "tags": [
                    "Account"
                ],
                "summary": "Get all transactions of an account",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Wallet ID",
                        "name": "walletId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Account ID",
                        "name": "accountId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "Page",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Limit",
                        "name": "limit",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/api.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "result": {
                                            "type": "array",
                                            "items": {
                                                "$ref": "#/definitions/model.Transaction"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/backoffice/wallets/{walletId}/accounts/{accountId}/transactions/sum": {
            "get": {
                "description": "Get the sum of all transactions of an account",
                "tags": [
                    "Account"
                ],
                "summary": "Get the sum of all transactions of an account",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Wallet ID",
                        "name": "walletId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Account ID",
                        "name": "accountId",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/api.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "result": {
                                            "type": "number"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/backoffice/wallets/{walletId}/check-integrity": {
            "get": {
                "description": "Check the integrity of a wallet by comparing the sum of accounts and transactions",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Wallet"
                ],
                "summary": "Check the integrity of a wallet",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Wallet ID",
                        "name": "walletId",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/api.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "result": {
                                            "type": "object",
                                            "additionalProperties": true
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/backoffice/wallets/{walletId}/transactions": {
            "get": {
                "description": "Get all transactions of a wallet",
                "tags": [
                    "Transaction"
                ],
                "summary": "Get all transactions of a wallet",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Wallet ID",
                        "name": "walletId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "Page",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Limit",
                        "name": "limit",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/api.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "result": {
                                            "type": "array",
                                            "items": {
                                                "$ref": "#/definitions/model.Transaction"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            },
            "post": {
                "description": "Create a transaction based on the provided request",
                "consumes": [
                    "application/json"
                ],
                "tags": [
                    "Transaction"
                ],
                "summary": "Create a transaction",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Wallet ID",
                        "name": "walletId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Create Transaction Request",
                        "name": "req",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/api.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "result": {
                                            "$ref": "#/definitions/model.Transaction"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/backoffice/wallets/{walletId}/transactions/exchange": {
            "post": {
                "description": "Create an exchange transaction based on the provided request",
                "consumes": [
                    "application/json"
                ],
                "tags": [
                    "Transaction"
                ],
                "summary": "Create an exchange transaction",
                "parameters": [
                    {
                        "description": "Create Exchange Transaction Request",
                        "name": "req",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/api.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "result": {
                                            "$ref": "#/definitions/service.ExchangeResponse"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/backoffice/wallets/{walletId}/transactions/sum": {
            "get": {
                "description": "Get the sum of all transactions of a wallet",
                "tags": [
                    "Transaction"
                ],
                "summary": "Get the sum of all transactions of a wallet",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Wallet ID",
                        "name": "walletId",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/api.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "result": {
                                            "type": "integer"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "api.ErrorResponse": {
            "type": "object",
            "properties": {
                "error": {
                    "$ref": "#/definitions/api.ErrorResponseBody"
                },
                "success": {
                    "type": "boolean"
                }
            }
        },
        "api.ErrorResponseBody": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "string"
                },
                "fields": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "httpCode": {
                    "type": "integer"
                },
                "message": {
                    "type": "string"
                },
                "reason": {
                    "type": "string"
                }
            }
        },
        "api.List-model_Program": {
            "type": "object",
            "properties": {
                "items": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/model.Program"
                    }
                },
                "limit": {
                    "type": "integer"
                },
                "page": {
                    "type": "integer"
                },
                "total": {
                    "type": "integer"
                }
            }
        },
        "api.SuccessResponse": {
            "type": "object",
            "properties": {
                "result": {},
                "success": {
                    "type": "boolean"
                }
            }
        },
        "model.Account": {
            "type": "object",
            "properties": {
                "balance": {
                    "type": "integer"
                },
                "createdAt": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "isActive": {
                    "type": "boolean"
                },
                "updatedAt": {
                    "type": "string"
                },
                "user": {
                    "$ref": "#/definitions/model.User"
                },
                "userId": {
                    "type": "string"
                },
                "version": {
                    "type": "integer"
                },
                "walletId": {
                    "type": "string"
                }
            }
        },
        "model.Audit": {
            "type": "object",
            "properties": {
                "actor": {
                    "type": "string"
                },
                "actorId": {
                    "type": "string"
                },
                "createdAt": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "newRecord": {
                    "description": "@swaggertype object",
                    "allOf": [
                        {
                            "$ref": "#/definitions/types.JSONB"
                        }
                    ]
                },
                "oldRecord": {
                    "description": "@swaggertype object",
                    "allOf": [
                        {
                            "$ref": "#/definitions/types.JSONB"
                        }
                    ]
                },
                "operation": {
                    "type": "string"
                },
                "recordId": {
                    "type": "string"
                },
                "remarks": {
                    "type": "string"
                },
                "table": {
                    "type": "string"
                }
            }
        },
        "model.ExchangeRate": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "exchangeRate": {
                    "description": "@swaggertype number",
                    "type": "number"
                },
                "fromWalletId": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "minimumAmount": {
                    "type": "integer"
                },
                "tierId": {
                    "type": "string"
                },
                "toWalletId": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        },
        "model.Program": {
            "type": "object",
            "properties": {
                "condition": {
                    "$ref": "#/definitions/types.JSONB"
                },
                "createdAt": {
                    "type": "string"
                },
                "effect": {
                    "$ref": "#/definitions/types.JSONB"
                },
                "id": {
                    "type": "integer"
                },
                "isActive;default:false": {
                    "type": "boolean"
                },
                "limitGlobal": {
                    "type": "integer"
                },
                "limitPerUser": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                },
                "triggerSlug": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                },
                "validFrom": {
                    "type": "string"
                },
                "validUntil": {
                    "type": "string"
                },
                "walletId": {
                    "type": "string"
                }
            }
        },
        "model.Transaction": {
            "type": "object",
            "properties": {
                "accountId": {
                    "type": "string"
                },
                "amount": {
                    "type": "integer"
                },
                "availableAmount": {
                    "type": "integer"
                },
                "createdAt": {
                    "type": "string"
                },
                "expireAt": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "metadata": {
                    "$ref": "#/definitions/types.JSONB"
                },
                "newBalance": {
                    "type": "integer"
                },
                "previousBalance": {
                    "type": "integer"
                },
                "programId": {
                    "type": "string"
                },
                "reason": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                },
                "version": {
                    "type": "integer"
                },
                "walletId": {
                    "type": "string"
                }
            }
        },
        "model.Trigger": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                },
                "properties": {
                    "$ref": "#/definitions/types.JSONB"
                },
                "slug": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        },
        "model.User": {
            "type": "object",
            "properties": {
                "accounts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/model.Account"
                    }
                },
                "createdAt": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "isActive;default:true": {
                    "type": "boolean"
                },
                "tierId": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        },
        "model.Wallet": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "currency": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "isActive": {
                    "type": "boolean"
                },
                "isArchived": {
                    "type": "boolean"
                },
                "isMonetary": {
                    "type": "boolean"
                },
                "limitGlobal": {
                    "type": "integer"
                },
                "limitPerUser": {
                    "type": "integer"
                },
                "minimumWithdrawal": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                },
                "pointsExpireAfter": {
                    "description": "@swaggertype string",
                    "allOf": [
                        {
                            "$ref": "#/definitions/types.Interval"
                        }
                    ]
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        },
        "service.CreateExchangeRateRequest": {
            "type": "object",
            "required": [
                "exchangeRate",
                "fromWalletId",
                "toWalletId"
            ],
            "properties": {
                "exchangeRate": {
                    "type": "number"
                },
                "fromWalletId": {
                    "type": "string"
                },
                "tierId": {
                    "type": "string"
                },
                "toWalletId": {
                    "type": "string"
                }
            }
        },
        "service.CreateProgramRequest": {
            "type": "object",
            "required": [
                "condition",
                "effect",
                "name",
                "triggerSlug",
                "validFrom",
                "walletId"
            ],
            "properties": {
                "condition": {
                    "$ref": "#/definitions/types.JSONB"
                },
                "effect": {
                    "$ref": "#/definitions/types.JSONB"
                },
                "isActive": {
                    "type": "boolean"
                },
                "limitPerUser": {
                    "type": "integer"
                },
                "name": {
                    "type": "string",
                    "maxLength": 100,
                    "minLength": 1
                },
                "triggerSlug": {
                    "type": "string"
                },
                "validFrom": {
                    "type": "string"
                },
                "validUntil": {
                    "type": "string"
                },
                "walletId": {
                    "type": "string"
                }
            }
        },
        "service.CreateTriggerRequest": {
            "type": "object",
            "required": [
                "name",
                "properties",
                "slug"
            ],
            "properties": {
                "name": {
                    "type": "string",
                    "maxLength": 100,
                    "minLength": 1
                },
                "properties": {
                    "type": "object",
                    "additionalProperties": true
                },
                "slug": {
                    "type": "string"
                }
            }
        },
        "service.CreateUserRequest": {
            "type": "object",
            "required": [
                "id"
            ],
            "properties": {
                "id": {
                    "type": "string",
                    "maxLength": 20,
                    "minLength": 1
                },
                "tierId": {
                    "type": "string"
                }
            }
        },
        "service.CreateWalletRequest": {
            "type": "object",
            "required": [
                "currency",
                "id",
                "name"
            ],
            "properties": {
                "currency": {
                    "type": "string",
                    "maxLength": 4,
                    "minLength": 1
                },
                "description": {
                    "type": "string",
                    "maxLength": 255
                },
                "id": {
                    "type": "string"
                },
                "isMonetary": {
                    "type": "boolean"
                },
                "limitGlobal": {
                    "type": "integer"
                },
                "limitPerUser": {
                    "type": "integer"
                },
                "name": {
                    "type": "string",
                    "maxLength": 100,
                    "minLength": 1
                },
                "pointsExpireAfter": {
                    "type": "integer"
                }
            }
        },
        "service.ExchangeResponse": {
            "type": "object",
            "properties": {
                "fromTransaction": {
                    "$ref": "#/definitions/model.Transaction"
                },
                "toTransaction": {
                    "$ref": "#/definitions/model.Transaction"
                }
            }
        },
        "service.UpdateProgramRequest": {
            "type": "object",
            "properties": {
                "condition": {
                    "$ref": "#/definitions/types.JSONB"
                },
                "effect": {
                    "$ref": "#/definitions/types.JSONB"
                },
                "isActive": {
                    "type": "boolean"
                },
                "limitPerUser": {
                    "type": "integer"
                },
                "name": {
                    "type": "string",
                    "maxLength": 100,
                    "minLength": 1
                },
                "triggerSlug": {
                    "type": "string"
                },
                "validFrom": {
                    "type": "string"
                },
                "validUntil": {
                    "type": "string"
                },
                "walletId": {
                    "type": "string"
                }
            }
        },
        "service.UpdateTriggerRequest": {
            "type": "object",
            "properties": {
                "name": {
                    "type": "string",
                    "maxLength": 100,
                    "minLength": 1
                },
                "properties": {
                    "type": "object",
                    "additionalProperties": true
                },
                "slug": {
                    "type": "string"
                }
            }
        },
        "service.UpdateWalletRequest": {
            "type": "object",
            "required": [
                "currency",
                "name"
            ],
            "properties": {
                "currency": {
                    "type": "string"
                },
                "description": {
                    "type": "string",
                    "maxLength": 255
                },
                "isMonetary": {
                    "type": "boolean"
                },
                "limitGlobal": {
                    "type": "integer"
                },
                "limitPerUser": {
                    "type": "integer"
                },
                "name": {
                    "type": "string",
                    "maxLength": 100,
                    "minLength": 1
                },
                "pointsExpireAfter": {
                    "type": "integer"
                }
            }
        },
        "types.Interval": {
            "type": "integer",
            "enum": [
                -9223372036854775808,
                9223372036854775807,
                1,
                1000,
                1000000,
                1000000000,
                60000000000,
                3600000000000
            ],
            "x-enum-varnames": [
                "minDuration",
                "maxDuration",
                "Nanosecond",
                "Microsecond",
                "Millisecond",
                "Second",
                "Minute",
                "Hour"
            ]
        },
        "types.JSONB": {
            "type": "object",
            "additionalProperties": true
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "http://localhost:3401",
        BasePath:         "/api/v1",
        Schemes:          []string{},
        Title:            "Digital Wallet API",
        Description:      "This is the Digital Wallet API documentation",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package model

import (
        "gorm.io/gorm"
        "time"
)

type Account struct {
        Auditable
        ID        string    `gorm:"column:id;primaryKey" json:"id"`
        WalletID  string    `gorm:"column:wallet_id" json:"walletId"`
        UserID    string    `gorm:"column:user_id" json:"userId"`
        User      *User     `gorm:"foreignKey:UserID;references:ID" json:"user,omitempty"`
        Balance   uint64    `gorm:"column:balance;" json:"balance"`
        Version   uint64    `gorm:"column:version" json:"version"`
        IsActive  bool      `gorm:"column:is_active;default:true" json:"isActive"`
        CreatedAt time.Time `gorm:"column:created_at" json:"createdAt"`
        UpdatedAt time.Time `gorm:"column:updated_at" json:"updatedAt"`
}

func (m *Account) TableName() string <span class="cov0" title="0">{
        return "accounts"
}</span>

func (m *Account) AfterCreate(tx *gorm.DB) error <span class="cov0" title="0">{
        audit, err := m.CreateAudit(m.TableName(), AuditOperationCreate, m.ID, m)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return tx.Create(audit).Error</span>
}

func (m *Account) AfterUpdate(tx *gorm.DB) error <span class="cov0" title="0">{
        audit, err := m.CreateAudit(m.TableName(), AuditOperationUpdate, m.ID, m)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return tx.Create(audit).Error</span>
}

func (m *Account) AfterDelete(tx *gorm.DB) error <span class="cov0" title="0">{
        audit, err := m.CreateAudit(m.TableName(), AuditOperationDelete, m.ID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return tx.Create(audit).Error</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package model

import (
        "github.com/abdelrahman146/digital-wallet/pkg/types"
        "time"
)

const (
        AuditOperationCreate = "CREATE"
        AuditOperationUpdate = "UPDATE"
        AuditOperationDelete = "DELETE"
)

type Audit struct {
        ID        string  `gorm:"column:id;primaryKey;default:uuid_generate_v4()" json:"id"`
        Operation string  `gorm:"column:operation" json:"operation"`
        Table     string  `gorm:"column:table_name" json:"table"`
        RecordID  string  `gorm:"column:record_id" json:"recordId"`
        Actor     string  `gorm:"column:actor" json:"actor"`
        ActorID   string  `gorm:"column:actor_id" json:"actorId"`
        Remarks   *string `gorm:"column:remarks" json:"remarks"`
        // @swaggertype object
        OldRecord *types.JSONB `gorm:"column:old_record" json:"oldRecord"`
        // @swaggertype object
        NewRecord *types.JSONB `gorm:"column:new_record" json:"newRecord"`
        CreatedAt time.Time    `gorm:"column:created_at" json:"createdAt"`
}

func (Audit) TableName() string <span class="cov0" title="0">{
        return "audit"
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package model

import (
        "github.com/abdelrahman146/digital-wallet/pkg/types"
)

type Auditable struct {
        actor     string
        actorId   string
        remarks   *string
        oldRecord interface{}
}

func (a *Auditable) SetActor(actor string, actorId string) <span class="cov0" title="0">{
        a.actor = actor
        a.actorId = actorId
}</span>

func (a *Auditable) GetActor() (actor string, actorId string) <span class="cov0" title="0">{
        return a.actor, a.actorId
}</span>

func (a *Auditable) SetRemarks(remarks string) <span class="cov0" title="0">{
        a.remarks = &amp;remarks
}</span>

func (a *Auditable) GetRemarks() *string <span class="cov0" title="0">{
        return a.remarks
}</span>

func (a *Auditable) SetOldRecord(oldRecord interface{}) <span class="cov0" title="0">{
        a.oldRecord = oldRecord
}</span>

func (a *Auditable) GetOldRecord() interface{} <span class="cov0" title="0">{
        return a.oldRecord
}</span>

func (a *Auditable) CreateAudit(table, operation, recordId string, newRecord interface{}) (*Audit, error) <span class="cov0" title="0">{
        var oldRecordJSON types.JSONB
        var newRecordJSON types.JSONB
        audit := &amp;Audit{
                Actor:     a.actor,
                ActorID:   a.actorId,
                Table:     table,
                Operation: operation,
                RecordID:  recordId,
                Remarks:   a.remarks,
        }
        if a.oldRecord != nil </span><span class="cov0" title="0">{
                if err := types.StructToJSONB(a.oldRecord, &amp;oldRecordJSON); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">audit.OldRecord = &amp;oldRecordJSON</span>
        }
        <span class="cov0" title="0">if newRecord != nil </span><span class="cov0" title="0">{
                if err := types.StructToJSONB(newRecord, &amp;newRecordJSON); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">audit.NewRecord = &amp;newRecordJSON</span>
        }
        <span class="cov0" title="0">return audit, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package model

import (
        "github.com/shopspring/decimal"
        "gorm.io/gorm"
        "strconv"
        "time"
)

type ExchangeRate struct {
        Auditable
        ID           uint64  `gorm:"column:id;primary_key" json:"id"`
        FromWalletID string  `gorm:"column:from_wallet_id" json:"fromWalletId"`
        ToWalletID   string  `gorm:"column:to_wallet_id" json:"toWalletId"`
        TierID       *string `gorm:"column:tier_id" json:"tierId"`
        // @swaggertype number
        ExchangeRate  decimal.Decimal `gorm:"column:exchange_rate" json:"exchangeRate"`
        MinimumAmount *uint64         `gorm:"column:minimum_amount" json:"minimumAmount"`
        CreatedAt     time.Time       `gorm:"column:created_at" json:"createdAt"`
        UpdatedAt     time.Time       `gorm:"column:updated_at" json:"updatedAt"`
}

func (m *ExchangeRate) TableName() string <span class="cov0" title="0">{
        return "exchange_rates"
}</span>

func (m *ExchangeRate) AfterCreate(tx *gorm.DB) error <span class="cov0" title="0">{
        audit, err := m.CreateAudit(m.TableName(), AuditOperationCreate, strconv.FormatUint(m.ID, 10), m)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return tx.Create(audit).Error</span>
}

func (m *ExchangeRate) AfterUpdate(tx *gorm.DB) error <span class="cov0" title="0">{
        audit, err := m.CreateAudit(m.TableName(), AuditOperationUpdate, strconv.FormatUint(m.ID, 10), m)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return tx.Create(audit).Error</span>
}

func (m *ExchangeRate) AfterDelete(tx *gorm.DB) error <span class="cov0" title="0">{
        audit, err := m.CreateAudit(m.TableName(), AuditOperationDelete, strconv.FormatUint(m.ID, 10), nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return tx.Create(audit).Error</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package model

import (
        "github.com/abdelrahman146/digital-wallet/pkg/types"
        "gorm.io/gorm"
        "strconv"
        "time"
)

type Program struct {
        Auditable
        ID           uint64      `json:"id" gorm:"column:id;primaryKey"`
        Name         string      `json:"name" gorm:"column:name"`
        WalletID     string      `json:"walletId" gorm:"column:wallet_id"`
        TriggerSlug  string      `json:"triggerSlug" gorm:"column:trigger_slug"`
        Condition    types.JSONB `json:"condition" gorm:"column:condition"`
        Effect       types.JSONB `json:"effect" gorm:"column:effect"`
        ValidFrom    time.Time   `json:"validFrom" gorm:"column:valid_from"`
        ValidUntil   *time.Time  `json:"validUntil" gorm:"column:valid_until"`
        IsActive     bool        `json:"isActive;default:false" gorm:"column:is_active"`
        LimitPerUser *uint64     `json:"limitPerUser" gorm:"column:limit_per_user"`
        LimitGlobal  *uint64     `json:"limitGlobal" gorm:"column:limit_global"`
        CreatedAt    time.Time   `json:"createdAt" gorm:"column:created_at"`
        UpdatedAt    time.Time   `json:"updatedAt" gorm:"column:updated_at"`
}

func (m *Program) TableName() string <span class="cov0" title="0">{
        return "programs"
}</span>

func (m *Program) AfterCreate(tx *gorm.DB) error <span class="cov0" title="0">{
        audit, err := m.CreateAudit(m.TableName(), AuditOperationCreate, strconv.FormatUint(m.ID, 10), m)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return tx.Create(audit).Error</span>
}

func (m *Program) AfterUpdate(tx *gorm.DB) error <span class="cov0" title="0">{
        audit, err := m.CreateAudit(m.TableName(), AuditOperationUpdate, strconv.FormatUint(m.ID, 10), m)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return tx.Create(audit).Error</span>
}

func (m *Program) AfterDelete(tx *gorm.DB) error <span class="cov0" title="0">{
        audit, err := m.CreateAudit(m.TableName(), AuditOperationDelete, strconv.FormatUint(m.ID, 10), nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return tx.Create(audit).Error</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package model

import (
        "gorm.io/gorm"
        "time"
)

type Tier struct {
        Auditable
        ID          string    `gorm:"column:id;primaryKey;" json:"id"`
        Name        string    `gorm:"column:name" json:"name"`
        Description *string   `gorm:"column:description" json:"description"`
        CreatedAt   time.Time `gorm:"column:created_at" json:"createdAt"`
        UpdatedAt   time.Time `gorm:"column:updated_at" json:"updatedAt"`
}

func (m *Tier) TableName() string <span class="cov0" title="0">{
        return "tiers"
}</span>

func (m *Tier) AfterCreate(tx *gorm.DB) error <span class="cov0" title="0">{
        audit, err := m.CreateAudit(m.TableName(), AuditOperationCreate, m.ID, m)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return tx.Create(audit).Error</span>
}

func (m *Tier) AfterUpdate(tx *gorm.DB) error <span class="cov0" title="0">{
        audit, err := m.CreateAudit(m.TableName(), AuditOperationUpdate, m.ID, m)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return tx.Create(audit).Error</span>
}

func (m *Tier) AfterDelete(tx *gorm.DB) error <span class="cov0" title="0">{
        audit, err := m.CreateAudit(m.TableName(), AuditOperationDelete, m.ID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return tx.Create(audit).Error</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package model

import (
        "github.com/abdelrahman146/digital-wallet/pkg/types"
        "gorm.io/gorm"
        "time"
)

const (
        TransactionTypeDebit  = "DEBIT"
        TransactionTypeCredit = "CREDIT"
)

const (
        TransactionReasonDeposit    = "DEPOSIT"
        TransactionReasonWithdrawal = "WITHDRAWAL"
        TransactionReasonExchange   = "EXCHANGE"
        TransactionReasonPurchase   = "PURCHASE"
        TransactionReasonRedeem     = "REDEEM"
        TransactionReasonPenalty    = "PENALTY"
        TransactionReasonExpired    = "EXPIRED"
)

type Transaction struct {
        Auditable
        ID              string      `gorm:"column:id;primaryKey" json:"id"`
        Type            string      `gorm:"column:type" json:"type"`
        WalletID        string      `gorm:"column:wallet_id" json:"walletId"`
        AccountID       string      `gorm:"column:account_id" json:"accountId"`
        Reason          string      `gorm:"column:reason" json:"reason"`
        Metadata        types.JSONB `gorm:"column:metadata;type:jsonb" json:"metadata"`
        ProgramID       *string     `gorm:"column:program_id" json:"programId"`
        Amount          uint64      `gorm:"column:amount" json:"amount"`
        AvailableAmount uint64      `gorm:"column:available_amount" json:"availableAmount"`
        ExpireAt        *time.Time  `gorm:"column:expire_at" json:"expireAt"`
        PreviousBalance uint64      `gorm:"column:previous_balance" json:"previousBalance"`
        NewBalance      uint64      `gorm:"column:new_balance" json:"newBalance"`
        Version         uint64      `gorm:"column:version" json:"version"`
        CreatedAt       time.Time   `gorm:"column:created_at" json:"createdAt"`
}

func (m *Transaction) TableName() string <span class="cov0" title="0">{
        return "transactions"
}</span>

func (m *Transaction) AfterCreate(tx *gorm.DB) error <span class="cov0" title="0">{
        audit, err := m.CreateAudit(m.TableName(), AuditOperationCreate, m.ID, m)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return tx.Create(audit).Error</span>
}

func (m *Transaction) AfterUpdate(tx *gorm.DB) error <span class="cov0" title="0">{
        audit, err := m.CreateAudit(m.TableName(), AuditOperationUpdate, m.ID, m)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return tx.Create(audit).Error</span>
}

func (m *Transaction) AfterDelete(tx *gorm.DB) error <span class="cov0" title="0">{
        audit, err := m.CreateAudit(m.TableName(), AuditOperationDelete, m.ID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return tx.Create(audit).Error</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package model

import (
        "github.com/abdelrahman146/digital-wallet/pkg/types"
        "gorm.io/gorm"
        "strconv"
        "time"
)

type Trigger struct {
        Auditable
        ID         uint64      `json:"id" gorm:"column:id;primaryKey"`
        Name       string      `json:"name" gorm:"column:name"`
        Slug       string      `json:"slug" gorm:"column:slug"`
        Properties types.JSONB `json:"properties" gorm:"column:properties"`
        CreatedAt  time.Time   `json:"createdAt" gorm:"column:created_at"`
        UpdatedAt  time.Time   `json:"updatedAt" gorm:"column:updated_at"`
}

func (m *Trigger) TableName() string <span class="cov0" title="0">{
        return "triggers"
}</span>

func (m *Trigger) AfterCreate(tx *gorm.DB) error <span class="cov0" title="0">{
        audit, err := m.CreateAudit(m.TableName(), AuditOperationCreate, strconv.FormatUint(m.ID, 10), m)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return tx.Create(audit).Error</span>
}

func (m *Trigger) AfterUpdate(tx *gorm.DB) error <span class="cov0" title="0">{
        audit, err := m.CreateAudit(m.TableName(), AuditOperationUpdate, strconv.FormatUint(m.ID, 10), m)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return tx.Create(audit).Error</span>
}

func (m *Trigger) AfterDelete(tx *gorm.DB) error <span class="cov0" title="0">{
        audit, err := m.CreateAudit(m.TableName(), AuditOperationDelete, strconv.FormatUint(m.ID, 10), nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return tx.Create(audit).Error</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package model

import (
        "gorm.io/gorm"
        "time"
)

type User struct {
        Auditable
        ID        string    `json:"id" gorm:"column:id;primaryKey"`
        TierID    *string   `json:"tierId" gorm:"column:tier_id"`
        IsActive  bool      `json:"isActive;default:true" gorm:"column:is_active"`
        CreatedAt time.Time `json:"createdAt" gorm:"column:created_at"`
        UpdatedAt time.Time `json:"updatedAt" gorm:"column:updated_at"`
        Accounts  []Account `json:"accounts,omitempty" gorm:"foreignKey:UserID;references:ID"`
}

func (m *User) TableName() string <span class="cov0" title="0">{
        return "users"
}</span>

func (m *User) AfterCreate(tx *gorm.DB) error <span class="cov0" title="0">{
        audit, err := m.CreateAudit(m.TableName(), AuditOperationCreate, m.ID, m)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return tx.Create(audit).Error</span>
}

func (m *User) AfterUpdate(tx *gorm.DB) error <span class="cov0" title="0">{
        audit, err := m.CreateAudit(m.TableName(), AuditOperationUpdate, m.ID, m)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return tx.Create(audit).Error</span>
}

func (m *User) AfterDelete(tx *gorm.DB) error <span class="cov0" title="0">{
        audit, err := m.CreateAudit(m.TableName(), AuditOperationDelete, m.ID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return tx.Create(audit).Error</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package model

import (
        "github.com/abdelrahman146/digital-wallet/pkg/types"
        "gorm.io/gorm"
        "time"
)

type Wallet struct {
        Auditable
        ID          string  `gorm:"column:id;primaryKey" json:"id"`
        Name        string  `gorm:"column:name" json:"name"`
        Description *string `gorm:"column:description" json:"description"`
        Currency    string  `gorm:"column:currency" json:"currency"`
        // @swaggertype string
        PointsExpireAfter *types.Interval `gorm:"column:points_expire_after" json:"pointsExpireAfter"`
        LimitPerUser      *uint64         `gorm:"column:limit_per_user" json:"limitPerUser"`
        LimitGlobal       *uint64         `gorm:"column:limit_global" json:"limitGlobal"`
        MinimumWithdrawal *uint64         `gorm:"column:minimum_withdrawal" json:"minimumWithdrawal"`
        IsMonetary        bool            `gorm:"column:is_monetary;default:false" json:"isMonetary"`
        IsActive          bool            `gorm:"column:is_active;default:true" json:"isActive"`
        IsArchived        bool            `gorm:"column:is_archived;default:false" json:"isArchived"`
        CreatedAt         time.Time       `gorm:"column:created_at" json:"createdAt"`
        UpdatedAt         time.Time       `gorm:"column:updated_at" json:"updatedAt"`
}

func (m *Wallet) TableName() string <span class="cov0" title="0">{
        return "wallets"
}</span>

func (m *Wallet) AfterCreate(tx *gorm.DB) error <span class="cov0" title="0">{
        audit, err := m.CreateAudit(m.TableName(), AuditOperationCreate, m.ID, m)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return tx.Create(audit).Error</span>
}

func (m *Wallet) AfterUpdate(tx *gorm.DB) error <span class="cov0" title="0">{
        audit, err := m.CreateAudit(m.TableName(), AuditOperationUpdate, m.ID, m)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return tx.Create(audit).Error</span>
}

func (m *Wallet) AfterDelete(tx *gorm.DB) error <span class="cov0" title="0">{
        audit, err := m.CreateAudit(m.TableName(), AuditOperationDelete, m.ID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return tx.Create(audit).Error</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package repository

import (
        "context"
        "github.com/abdelrahman146/digital-wallet/internal/model"
        "github.com/abdelrahman146/digital-wallet/internal/resource"
        "github.com/abdelrahman146/digital-wallet/pkg/api"
        "github.com/abdelrahman146/digital-wallet/pkg/logger"
)

type AccountRepo interface {
        // CreateAccount Creates a new account
        CreateAccount(ctx context.Context, account *model.Account) error
        // DeleteAccount Deletes an account
        DeleteAccount(ctx context.Context, account *model.Account) error
        // FetchAccountByID Retrieves an account by its account ID
        FetchAccountByID(ctx context.Context, accountId string) (*model.Account, error)
        // FetchAccountByUserID Retrieves an account by wallet ID and user ID
        FetchAccountByUserID(ctx context.Context, walletId, userId string) (*model.Account, error)
        // FetchWalletAccounts Retrieves a paginated list of accounts for a wallet
        FetchWalletAccounts(ctx context.Context, walletId string, page int, limit int) ([]model.Account, error)
        // CountWalletAccounts Retrieves the total number of accounts for a wallet
        CountWalletAccounts(ctx context.Context, walletId string) (int64, error)
        // SumWalletAccounts Retrieves the sum of account balances for a wallet
        SumWalletAccounts(ctx context.Context, walletId string) (uint64, error)
}

type accountRepo struct {
        resources *resource.Resources
}

// NewAccountRepo initializes the account repository
func NewAccountRepo(resources *resource.Resources) AccountRepo <span class="cov0" title="0">{
        return &amp;accountRepo{resources: resources}
}</span>

// CreateAccount creates a new account and generates an account ID
func (r *accountRepo) CreateAccount(ctx context.Context, account *model.Account) error <span class="cov0" title="0">{
        // Generate account ID based on the wallet ID
        if err := r.resources.DB.Raw("SELECT generate_account_id(?);", account.WalletID).Scan(&amp;account.ID).Error; err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to generate account ID", logger.Field("error", err), logger.Field("account", account))
                return err
        }</span>
        // Create the account
        <span class="cov0" title="0">if err := r.resources.DB.Create(account).Error; err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to create account", logger.Field("error", err), logger.Field("account", account))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// FetchAccountByUserID retrieves an account by wallet ID and user ID
func (r *accountRepo) FetchAccountByUserID(ctx context.Context, walletId, userId string) (*model.Account, error) <span class="cov0" title="0">{
        var account model.Account
        err := r.resources.DB.Where("wallet_id = ? AND user_id = ?", walletId, userId).First(&amp;account).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to retrieve account by user ID", logger.Field("error", err), logger.Field("userId", userId), logger.Field("walletId", walletId))
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;account, nil</span>
}

// FetchAccountByID retrieves an account by its account ID
func (r *accountRepo) FetchAccountByID(ctx context.Context, accountId string) (*model.Account, error) <span class="cov0" title="0">{
        var account model.Account
        err := r.resources.DB.Where("id = ?", accountId).First(&amp;account).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to retrieve account by ID", logger.Field("error", err), logger.Field("accountId", accountId))
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;account, nil</span>
}

// SumWalletAccounts retrieves the sum of balances for accounts in a wallet
func (r *accountRepo) SumWalletAccounts(ctx context.Context, walletId string) (uint64, error) <span class="cov0" title="0">{
        var sum uint64
        err := r.resources.DB.Model(&amp;model.Account{}).Select("COALESCE(SUM(balance), 0)").Where("wallet_id = ?", walletId).Scan(&amp;sum).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to retrieve account balance sum", logger.Field("error", err), logger.Field("walletId", walletId))
                return 0, err
        }</span>
        <span class="cov0" title="0">return sum, nil</span>
}

// FetchWalletAccounts retrieves a paginated list of accounts for a wallet
func (r *accountRepo) FetchWalletAccounts(ctx context.Context, walletId string, page int, limit int) ([]model.Account, error) <span class="cov0" title="0">{
        var accounts []model.Account
        err := r.resources.DB.Where("wallet_id = ?", walletId).Order("created_at desc").
                Offset((page - 1) * limit).Limit(limit).Find(&amp;accounts).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to retrieve accounts", logger.Field("error", err), logger.Field("walletId", walletId))
                return nil, err
        }</span>
        <span class="cov0" title="0">return accounts, nil</span>
}

// CountWalletAccounts retrieves the total number of accounts in a wallet
func (r *accountRepo) CountWalletAccounts(ctx context.Context, walletId string) (int64, error) <span class="cov0" title="0">{
        var total int64
        err := r.resources.DB.Model(&amp;model.Account{}).Where("wallet_id = ?", walletId).Count(&amp;total).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to retrieve total accounts", logger.Field("error", err), logger.Field("walletId", walletId))
                return 0, err
        }</span>
        <span class="cov0" title="0">return total, nil</span>
}

// DeleteAccount deletes an account from the database
func (r *accountRepo) DeleteAccount(ctx context.Context, account *model.Account) error <span class="cov0" title="0">{
        if err := r.resources.DB.Delete(account).Error; err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to delete account", logger.Field("error", err), logger.Field("account", account))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package repository

import (
        "context"
        "github.com/abdelrahman146/digital-wallet/internal/model"
        "github.com/abdelrahman146/digital-wallet/internal/resource"
        "github.com/abdelrahman146/digital-wallet/pkg/api"
        "github.com/abdelrahman146/digital-wallet/pkg/logger"
)

type AuditRepo interface {
        // FetchTableAuditLogs retrieves a paginated list of audit logs for a table
        FetchTableAuditLogs(ctx context.Context, tableName string, page int, limit int) ([]model.Audit, error)
        // CountTableAuditLogs retrieves the total number of audit logs for a table
        CountTableAuditLogs(ctx context.Context, tableName string) (int64, error)
        // FetchRecordAuditLogs retrieves a paginated list of audit logs for a record
        FetchRecordAuditLogs(ctx context.Context, tableName, recordId string, page int, limit int) ([]model.Audit, error)
        // CountRecordAuditLogs retrieves the total number of audit logs for a record
        CountRecordAuditLogs(ctx context.Context, tableName, recordId string) (int64, error)
        // FetchActorAuditLogs retrieves a paginated list of audit logs for an actor
        FetchActorAuditLogs(ctx context.Context, actor, actorId string, page int, limit int) ([]model.Audit, error)
        // CountActorAuditLogs retrieves the total number of audit logs for an actor
        CountActorAuditLogs(ctx context.Context, actor, actorId string) (int64, error)
}

type auditRepo struct {
        resources *resource.Resources
}

func NewAuditRepo(resources *resource.Resources) AuditRepo <span class="cov0" title="0">{
        return &amp;auditRepo{resources: resources}
}</span>

// FetchTableAuditLogs retrieves a paginated list of audit logs for a table
func (r *auditRepo) FetchTableAuditLogs(ctx context.Context, tableName string, page int, limit int) ([]model.Audit, error) <span class="cov0" title="0">{
        var audits []model.Audit
        err := r.resources.DB.Where("table_name = ?", tableName).Order("created_at desc").Offset((page - 1) * limit).Limit(limit).Find(&amp;audits).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to fetch table audit logs", logger.Field("error", err), logger.Field("tableName", tableName))
                return nil, err
        }</span>
        <span class="cov0" title="0">return audits, nil</span>
}

// CountTableAuditLogs retrieves the total number of audit logs for a table
func (r *auditRepo) CountTableAuditLogs(ctx context.Context, tableName string) (int64, error) <span class="cov0" title="0">{
        var total int64
        err := r.resources.DB.Model(&amp;model.Audit{}).Where("table_name = ?", tableName).Count(&amp;total).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to count table audit logs", logger.Field("error", err), logger.Field("tableName", tableName))
                return 0, err
        }</span>
        <span class="cov0" title="0">return total, nil</span>
}

// FetchRecordAuditLogs retrieves a paginated list of audit logs for a record
func (r *auditRepo) FetchRecordAuditLogs(ctx context.Context, tableName, recordId string, page int, limit int) ([]model.Audit, error) <span class="cov0" title="0">{
        var audits []model.Audit
        err := r.resources.DB.Where("table_name = ? AND record_id = ?", tableName, recordId).Order("created_at desc").Offset((page - 1) * limit).Limit(limit).Find(&amp;audits).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to fetch record audit logs", logger.Field("error", err), logger.Field("tableName", tableName), logger.Field("recordId", recordId))
                return nil, err
        }</span>
        <span class="cov0" title="0">return audits, nil</span>
}

// CountRecordAuditLogs retrieves the total number of audit logs for a record
func (r *auditRepo) CountRecordAuditLogs(ctx context.Context, tableName, recordId string) (int64, error) <span class="cov0" title="0">{
        var total int64
        err := r.resources.DB.Model(&amp;model.Audit{}).Where("table_name = ? AND record_id = ?", tableName, recordId).Count(&amp;total).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to count record audit logs", logger.Field("error", err), logger.Field("tableName", tableName), logger.Field("recordId", recordId))
                return 0, err
        }</span>
        <span class="cov0" title="0">return total, nil</span>
}

// FetchActorAuditLogs retrieves a paginated list of audit logs for an actor
func (r *auditRepo) FetchActorAuditLogs(ctx context.Context, actor, actorId string, page int, limit int) ([]model.Audit, error) <span class="cov0" title="0">{
        var audits []model.Audit
        err := r.resources.DB.Where("actor = ? AND actor_id = ?", actor, actorId).Order("created_at desc").Offset((page - 1) * limit).Limit(limit).Find(&amp;audits).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to fetch actor audit logs", logger.Field("error", err), logger.Field("actorType", actor), logger.Field("actorId", actorId))
                return nil, err
        }</span>
        <span class="cov0" title="0">return audits, nil</span>
}

// CountActorAuditLogs retrieves the total number of audit logs for an actor
func (r *auditRepo) CountActorAuditLogs(ctx context.Context, actor, actorId string) (int64, error) <span class="cov0" title="0">{
        var total int64
        err := r.resources.DB.Model(&amp;model.Audit{}).Where("actor = ? AND actor_id = ?", actor, actorId).Count(&amp;total).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to count actor audit logs", logger.Field("error", err), logger.Field("actorType", actor), logger.Field("actorId", actorId))
                return 0, err
        }</span>
        <span class="cov0" title="0">return total, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package repository

import (
        "context"
        "github.com/abdelrahman146/digital-wallet/internal/model"
        "github.com/abdelrahman146/digital-wallet/internal/resource"
        "github.com/abdelrahman146/digital-wallet/pkg/api"
        "github.com/abdelrahman146/digital-wallet/pkg/logger"
)

type ExchangeRateRepo interface {
        // CreateExchangeRate Creates a new exchange rate
        CreateExchangeRate(ctx context.Context, exchangeRate *model.ExchangeRate) error
        // UpdateExchangeRate Updates an existing exchange rate
        UpdateExchangeRate(ctx context.Context, exchangeRate *model.ExchangeRate) error
        // DeleteExchangeRate Deletes an exchange rate by its ID
        DeleteExchangeRate(ctx context.Context, exchangeRate *model.ExchangeRate) error
        // FetchExchangeRateByID Retrieves an exchange rate by its ID
        FetchExchangeRateByID(ctx context.Context, exchangeRateId string) (*model.ExchangeRate, error)
        // FetchExchangeRate Retrieves an exchange rate by the source and destination wallet IDs, with an optional tier ID
        FetchExchangeRate(ctx context.Context, fromWalletId, toWalletId string, tierId *string) (*model.ExchangeRate, error)
        // FetchExchangeRates Retrieves a paginated list of exchange rates
        FetchExchangeRates(ctx context.Context, page int, limit int) ([]model.ExchangeRate, error)
        // CountExchangeRates Retrieves the total number of exchange rates
        CountExchangeRates(ctx context.Context) (int64, error)
        // FetchWalletExchangeRates Retrieves exchange rates by wallet ID with pagination
        FetchWalletExchangeRates(ctx context.Context, walletId string, page int, limit int) ([]model.ExchangeRate, error)
        // CountWalletExchangeRates Retrieves the total number of exchange rates for a specific wallet
        CountWalletExchangeRates(ctx context.Context, walletId string) (int64, error)
}

type exchangeRateRepo struct {
        resources *resource.Resources
}

// NewExchangeRateRepo initializes the exchange rate repository
func NewExchangeRateRepo(resources *resource.Resources) ExchangeRateRepo <span class="cov0" title="0">{
        return &amp;exchangeRateRepo{resources: resources}
}</span>

// FetchExchangeRateByID retrieves an exchange rate by its ID
func (r *exchangeRateRepo) FetchExchangeRateByID(ctx context.Context, exchangeRateId string) (*model.ExchangeRate, error) <span class="cov0" title="0">{
        var exchangeRate model.ExchangeRate
        err := r.resources.DB.Where("id = ?", exchangeRateId).First(&amp;exchangeRate).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to retrieve exchange rate by ID", logger.Field("error", err), logger.Field("exchangeRateId", exchangeRateId))
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;exchangeRate, nil</span>
}

// CreateExchangeRate creates a new exchange rate in the database
func (r *exchangeRateRepo) CreateExchangeRate(ctx context.Context, exchangeRate *model.ExchangeRate) error <span class="cov0" title="0">{
        if err := r.resources.DB.Create(exchangeRate).Error; err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to create exchange rate", logger.Field("error", err), logger.Field("exchangeRate", exchangeRate))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// FetchExchangeRates retrieves a paginated list of exchange rates
func (r *exchangeRateRepo) FetchExchangeRates(ctx context.Context, page int, limit int) ([]model.ExchangeRate, error) <span class="cov0" title="0">{
        var exchangeRates []model.ExchangeRate
        err := r.resources.DB.Order("created_at desc").Offset((page - 1) * limit).Limit(limit).Find(&amp;exchangeRates).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to retrieve exchange rates", logger.Field("error", err))
                return nil, err
        }</span>
        <span class="cov0" title="0">return exchangeRates, nil</span>
}

// CountExchangeRates retrieves the total number of exchange rates
func (r *exchangeRateRepo) CountExchangeRates(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        var total int64
        err := r.resources.DB.Model(&amp;model.ExchangeRate{}).Count(&amp;total).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to retrieve total exchange rates count", logger.Field("error", err))
                return 0, err
        }</span>
        <span class="cov0" title="0">return total, nil</span>
}

// FetchWalletExchangeRates retrieves exchange rates by wallet ID with pagination
func (r *exchangeRateRepo) FetchWalletExchangeRates(ctx context.Context, walletId string, page int, limit int) ([]model.ExchangeRate, error) <span class="cov0" title="0">{
        var exchangeRates []model.ExchangeRate
        err := r.resources.DB.Where("from_wallet_id = ?", walletId).Order("created_at desc").Offset((page - 1) * limit).Limit(limit).Find(&amp;exchangeRates).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to retrieve exchange rates by wallet ID", logger.Field("error", err), logger.Field("walletId", walletId))
                return nil, err
        }</span>
        <span class="cov0" title="0">return exchangeRates, nil</span>
}

// CountWalletExchangeRates retrieves the total number of exchange rates for a specific wallet
func (r *exchangeRateRepo) CountWalletExchangeRates(ctx context.Context, walletId string) (int64, error) <span class="cov0" title="0">{
        var total int64
        err := r.resources.DB.Model(&amp;model.ExchangeRate{}).Where("from_wallet_id = ?", walletId).Count(&amp;total).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to retrieve total exchange rates by wallet ID", logger.Field("error", err), logger.Field("walletId", walletId))
                return 0, err
        }</span>
        <span class="cov0" title="0">return total, nil</span>
}

// UpdateExchangeRate updates an existing exchange rate in the database
func (r *exchangeRateRepo) UpdateExchangeRate(ctx context.Context, exchangeRate *model.ExchangeRate) error <span class="cov0" title="0">{
        if err := r.resources.DB.Save(exchangeRate).Error; err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to update exchange rate", logger.Field("error", err), logger.Field("exchangeRate", exchangeRate))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteExchangeRate deletes an exchange rate
func (r *exchangeRateRepo) DeleteExchangeRate(ctx context.Context, exchangeRate *model.ExchangeRate) error <span class="cov0" title="0">{
        if err := r.resources.DB.Delete(exchangeRate).Error; err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to delete exchange rate", logger.Field("error", err), logger.Field("exchangeRate", exchangeRate))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// FetchExchangeRate retrieves an exchange rate by source wallet ID, destination wallet ID, and optionally a tier ID
func (r *exchangeRateRepo) FetchExchangeRate(ctx context.Context, fromWalletId, toWalletId string, tierId *string) (*model.ExchangeRate, error) <span class="cov0" title="0">{
        var exchangeRate model.ExchangeRate
        err := r.resources.DB.Where("from_wallet_id = ? AND to_wallet_id = ? AND tier_id = ?", fromWalletId, toWalletId, tierId).First(&amp;exchangeRate).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to retrieve exchange rate by wallet IDs and tier ID", logger.Field("error", err), logger.Field("fromWalletId", fromWalletId), logger.Field("toWalletId", toWalletId), logger.Field("tierId", tierId))
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;exchangeRate, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package repository

import (
        "context"
        "github.com/abdelrahman146/digital-wallet/internal/model"
        "github.com/abdelrahman146/digital-wallet/internal/resource"
        "github.com/abdelrahman146/digital-wallet/pkg/api"
        "github.com/abdelrahman146/digital-wallet/pkg/logger"
)

type ProgramRepo interface {
        // CreateProgram creates a new program
        CreateProgram(ctx context.Context, program *model.Program) error
        // UpdateProgram updates an existing program
        UpdateProgram(ctx context.Context, program *model.Program) error
        // DeleteProgram deletes a program
        DeleteProgram(ctx context.Context, program *model.Program) error
        // FetchProgramByID retrieves a program by its ID
        FetchProgramByID(ctx context.Context, id uint64) (*model.Program, error)
        // FetchTriggerPrograms retrieves programs for a specific trigger
        FetchTriggerPrograms(ctx context.Context, triggerSlug string) ([]*model.Program, error)
        // FetchProgramsByWalletID retrieves programs for a specific wallet
        FetchProgramsByWalletID(ctx context.Context, walletID uint64) ([]model.Program, error)
        // CountProgramsByWalletID retrieves the total number of programs for a specific wallet
        CountProgramsByWalletID(ctx context.Context, walletID uint64) (int64, error)
        // FetchPrograms retrieves a paginated list of programs
        FetchPrograms(ctx context.Context, page int, limit int) ([]model.Program, error)
        // CountPrograms retrieves the total number of programs
        CountPrograms(ctx context.Context) (int64, error)
}

type programRepo struct {
        resources *resource.Resources
}

func NewProgramRepo(resources *resource.Resources) ProgramRepo <span class="cov0" title="0">{
        return &amp;programRepo{resources: resources}
}</span>

func (r *programRepo) CreateProgram(ctx context.Context, program *model.Program) error <span class="cov0" title="0">{
        if err := r.resources.DB.Create(program).Error; err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to create program", logger.Field("error", err), logger.Field("program", program))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *programRepo) UpdateProgram(ctx context.Context, program *model.Program) error <span class="cov0" title="0">{
        if err := r.resources.DB.Save(program).Error; err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to update program", logger.Field("error", err), logger.Field("program", program))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *programRepo) DeleteProgram(ctx context.Context, program *model.Program) error <span class="cov0" title="0">{
        if err := r.resources.DB.Delete(program).Error; err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to delete program", logger.Field("error", err), logger.Field("program", program))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *programRepo) FetchProgramByID(ctx context.Context, id uint64) (*model.Program, error) <span class="cov0" title="0">{
        var program model.Program
        err := r.resources.DB.Where("id = ?", id).First(&amp;program).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to retrieve program by ID", logger.Field("error", err), logger.Field("id", id))
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;program, nil</span>
}

func (r *programRepo) FetchTriggerPrograms(ctx context.Context, triggerSlug string) ([]*model.Program, error) <span class="cov0" title="0">{
        var programs []*model.Program
        err := r.resources.DB.Where("trigger_slug = ?", triggerSlug).Find(&amp;programs).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to retrieve programs of a trigger", logger.Field("error", err), logger.Field("triggerSlug", triggerSlug))
                return nil, err
        }</span>
        <span class="cov0" title="0">return programs, nil</span>
}

func (r *programRepo) FetchProgramsByWalletID(ctx context.Context, walletID uint64) ([]model.Program, error) <span class="cov0" title="0">{
        var programs []model.Program
        err := r.resources.DB.Where("wallet_id = ?", walletID).Find(&amp;programs).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to retrieve programs by wallet ID", logger.Field("error", err), logger.Field("walletId", walletID))
                return nil, err
        }</span>
        <span class="cov0" title="0">return programs, nil</span>
}

func (r *programRepo) CountProgramsByWalletID(ctx context.Context, walletID uint64) (int64, error) <span class="cov0" title="0">{
        var total int64
        err := r.resources.DB.Model(&amp;model.Program{}).Where("wallet_id = ?", walletID).Count(&amp;total).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to retrieve total programs count by wallet ID", logger.Field("error", err), logger.Field("walletId", walletID))
                return 0, err
        }</span>
        <span class="cov0" title="0">return total, nil</span>
}

func (r *programRepo) FetchPrograms(ctx context.Context, page int, limit int) ([]model.Program, error) <span class="cov0" title="0">{
        var programs []model.Program
        err := r.resources.DB.Order("created_at desc").Offset((page - 1) * limit).Limit(limit).Find(&amp;programs).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to retrieve programs", logger.Field("error", err))
                return nil, err
        }</span>
        <span class="cov0" title="0">return programs, nil</span>
}

func (r *programRepo) CountPrograms(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        var total int64
        err := r.resources.DB.Model(&amp;model.Program{}).Count(&amp;total).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to retrieve total programs count", logger.Field("error", err))
                return 0, err
        }</span>
        <span class="cov0" title="0">return total, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package repository

import (
        "context"
        "github.com/abdelrahman146/digital-wallet/internal/model"
        "github.com/abdelrahman146/digital-wallet/internal/resource"
        "github.com/abdelrahman146/digital-wallet/pkg/api"
        "github.com/abdelrahman146/digital-wallet/pkg/logger"
)

type TierRepo interface {
        // CreateTier creates a new tier
        CreateTier(ctx context.Context, tier *model.Tier) error
        // DeleteTier deletes a tier
        DeleteTier(ctx context.Context, tier *model.Tier) error
        // FetchTierByID retrieves a tier by its ID
        FetchTierByID(ctx context.Context, tierId string) (*model.Tier, error)
        // FetchTiers retrieves a paginated list of tiers
        FetchTiers(ctx context.Context, page int, limit int) ([]model.Tier, error)
        // CountTiers retrieves the total number of tiers
        CountTiers(ctx context.Context) (int64, error)
}

type tierRepo struct {
        resources *resource.Resources
}

func NewTierRepo(resources *resource.Resources) TierRepo <span class="cov0" title="0">{
        return &amp;tierRepo{resources: resources}
}</span>

func (r *tierRepo) CreateTier(ctx context.Context, tier *model.Tier) error <span class="cov0" title="0">{
        if err := r.resources.DB.Create(tier).Error; err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("failed to create tier", logger.Field("error", err), logger.Field("tier", tier))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *tierRepo) FetchTierByID(ctx context.Context, tierId string) (*model.Tier, error) <span class="cov0" title="0">{
        var tier model.Tier
        err := r.resources.DB.Where("id = ?", tierId).First(&amp;tier).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("failed to get tier by id", logger.Field("error", err), logger.Field("tierId", tierId))
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;tier, nil</span>
}

func (r *tierRepo) FetchTiers(ctx context.Context, page int, limit int) ([]model.Tier, error) <span class="cov0" title="0">{
        var tiers []model.Tier
        err := r.resources.DB.Order("created_at desc").Offset((page - 1) * limit).Limit(limit).Find(&amp;tiers).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("failed to get tiers", logger.Field("error", err))
                return nil, err
        }</span>
        <span class="cov0" title="0">return tiers, nil</span>
}

func (r *tierRepo) CountTiers(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        var total int64
        err := r.resources.DB.Model(&amp;model.Tier{}).Count(&amp;total).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("failed to get total tiers", logger.Field("error", err))
                return 0, err
        }</span>
        <span class="cov0" title="0">return total, nil</span>
}

func (r *tierRepo) DeleteTier(ctx context.Context, tier *model.Tier) error <span class="cov0" title="0">{
        if err := r.resources.DB.Delete(tier).Error; err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("failed to delete tier", logger.Field("error", err), logger.Field("tier", tier))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package repository

import (
        "context"
        "fmt"
        "github.com/abdelrahman146/digital-wallet/internal/model"
        "github.com/abdelrahman146/digital-wallet/internal/resource"
        "github.com/abdelrahman146/digital-wallet/pkg/api"
        "github.com/abdelrahman146/digital-wallet/pkg/errs"
        "github.com/abdelrahman146/digital-wallet/pkg/logger"
        "github.com/abdelrahman146/digital-wallet/pkg/types"
        "gorm.io/gorm"
        "gorm.io/gorm/clause"
        "time"
)

type TransactionRepo interface {
        // FetchAccountTransactions Retrieves a list of transactions by account ID with pagination
        FetchAccountTransactions(ctx context.Context, accountId string, page int, limit int) ([]model.Transaction, error)
        // CountAccountTransactions Retrieves the total count of transactions by account ID
        CountAccountTransactions(ctx context.Context, accountId string) (int64, error)
        // FetchWalletTransactions Retrieves a list of transactions by wallet ID with pagination
        FetchWalletTransactions(ctx context.Context, walletId string, page int, limit int) ([]model.Transaction, error)
        // CountWalletTransactions Retrieves the total count of transactions by wallet ID
        CountWalletTransactions(ctx context.Context, walletId string) (int64, error)
        // SumAccountTransactions Retrieves the sum of transactions for a specific account ID
        SumAccountTransactions(ctx context.Context, accountId string) (uint64, error)
        // SumWalletTransactions Retrieves the sum of transactions for a specific wallet ID
        SumWalletTransactions(ctx context.Context, walletId string) (uint64, error)
        // FetchExpiredWalletTransactions Retrieves transactions for a wallet that have expired
        FetchExpiredWalletTransactions(ctx context.Context, walletId string) ([]model.Transaction, error)
        // SumExpiringAccountTransactions Retrieves the sum of transactions about to expire for a specific account ID
        SumExpiringAccountTransactions(ctx context.Context, accountId string, expireInterval types.Interval) (uint64, error)
        // CreateTransaction Creates a new transaction
        CreateTransaction(ctx context.Context, transaction *model.Transaction, accountVersion uint64) error
        // PerformExchange Performs an exchange between two accounts
        PerformExchange(ctx context.Context, from *ExchangeRequest, to *ExchangeRequest) error
}

type transactionRepo struct {
        resources *resource.Resources
}

// NewTransactionRepo initializes the transaction repository
func NewTransactionRepo(resources *resource.Resources) TransactionRepo <span class="cov0" title="0">{
        return &amp;transactionRepo{resources: resources}
}</span>

// FetchAccountTransactions retrieves transactions by account ID with pagination
func (r *transactionRepo) FetchAccountTransactions(ctx context.Context, accountId string, page int, limit int) ([]model.Transaction, error) <span class="cov0" title="0">{
        var transactions []model.Transaction
        err := r.resources.DB.Where("account_id = ?", accountId).Order("created_at desc").
                Offset((page - 1) * limit).Limit(limit).Find(&amp;transactions).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Error fetching transactions by account ID", logger.Field("error", err), logger.Field("accountId", accountId))
                return nil, err
        }</span>
        <span class="cov0" title="0">return transactions, nil</span>
}

// CountAccountTransactions retrieves the total number of transactions by account ID
func (r *transactionRepo) CountAccountTransactions(ctx context.Context, accountId string) (int64, error) <span class="cov0" title="0">{
        var total int64
        err := r.resources.DB.Model(&amp;model.Transaction{}).Where("account_id = ?", accountId).Count(&amp;total).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Error fetching total transactions by account ID", logger.Field("error", err), logger.Field("accountId", accountId))
                return 0, err
        }</span>
        <span class="cov0" title="0">return total, nil</span>
}

// SumAccountTransactions retrieves the sum of transaction amounts for a specific account ID
func (r *transactionRepo) SumAccountTransactions(ctx context.Context, accountId string) (uint64, error) <span class="cov0" title="0">{
        var sum uint64
        err := r.resources.DB.Model(&amp;model.Transaction{}).Select("COALESCE(SUM(amount), 0)").Where("account_id = ?", accountId).Scan(&amp;sum).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Error fetching transaction sum by account ID", logger.Field("error", err), logger.Field("accountId", accountId))
                return 0, err
        }</span>
        <span class="cov0" title="0">return sum, nil</span>
}

// SumExpiringAccountTransactions retrieves the sum of transactions that are about to expire for an account ID
func (r *transactionRepo) SumExpiringAccountTransactions(ctx context.Context, accountId string, expireInterval types.Interval) (uint64, error) <span class="cov0" title="0">{
        var sum uint64
        err := r.resources.DB.Model(&amp;model.Transaction{}).
                Select("COALESCE(SUM(amount), 0)").
                Where("account_id = ? AND expire_at &lt; ?", accountId, time.Now().Add(expireInterval.Duration()).Format(time.DateOnly)).
                Scan(&amp;sum).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Error fetching sum of expiring transactions", logger.Field("error", err), logger.Field("accountId", accountId))
                return 0, err
        }</span>
        <span class="cov0" title="0">return sum, nil</span>
}

// FetchWalletTransactions retrieves transactions by wallet ID with pagination
func (r *transactionRepo) FetchWalletTransactions(ctx context.Context, walletId string, page int, limit int) ([]model.Transaction, error) <span class="cov0" title="0">{
        var transactions []model.Transaction
        err := r.resources.DB.Where("wallet_id = ?", walletId).Order("created_at desc").
                Offset((page - 1) * limit).Limit(limit).Find(&amp;transactions).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Error fetching transactions by wallet ID", logger.Field("error", err))
                return nil, err
        }</span>
        <span class="cov0" title="0">return transactions, nil</span>
}

// CountWalletTransactions retrieves the total number of transactions by wallet ID
func (r *transactionRepo) CountWalletTransactions(ctx context.Context, walletId string) (int64, error) <span class="cov0" title="0">{
        var total int64
        err := r.resources.DB.Model(&amp;model.Transaction{}).Where("wallet_id = ?", walletId).Count(&amp;total).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Error fetching total transactions by wallet ID", logger.Field("error", err), logger.Field("walletId", walletId))
                return 0, err
        }</span>
        <span class="cov0" title="0">return total, nil</span>
}

// SumWalletTransactions retrieves the sum of transaction amounts for a specific wallet ID
func (r *transactionRepo) SumWalletTransactions(ctx context.Context, walletId string) (uint64, error) <span class="cov0" title="0">{
        var res []struct {
                Type string
                Sum  uint64
        }
        err := r.resources.DB.Model(&amp;model.Transaction{}).Where("wallet_id = ?", walletId).
                Select("type, COALESCE(SUM(amount), 0) as sum").Group("type").Scan(&amp;res).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Error fetching transaction sums by wallet ID", logger.Field("error", err), logger.Field("walletId", walletId))
                return 0, err
        }</span>

        // Calculate the net sum (credits - debits)
        <span class="cov0" title="0">var credit, debit uint64
        for _, r := range res </span><span class="cov0" title="0">{
                if r.Type == model.TransactionTypeCredit </span><span class="cov0" title="0">{
                        credit = r.Sum
                }</span> else<span class="cov0" title="0"> if r.Type == model.TransactionTypeDebit </span><span class="cov0" title="0">{
                        debit = r.Sum
                }</span>
        }
        <span class="cov0" title="0">return credit - debit, nil</span>
}

// FetchExpiredWalletTransactions retrieves expired transactions by wallet ID
func (r *transactionRepo) FetchExpiredWalletTransactions(ctx context.Context, walletId string) ([]model.Transaction, error) <span class="cov0" title="0">{
        var transactions []model.Transaction
        err := r.resources.DB.Where("wallet_id = ? AND expire_at &lt; ? AND available_amount &gt; 0", walletId, time.Now().Format(time.DateOnly)).Find(&amp;transactions).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Error fetching expired transactions", logger.Field("error", err))
                return nil, err
        }</span>
        <span class="cov0" title="0">return transactions, nil</span>
}

// CreateTransaction creates a new transaction for the specified account
func (r *transactionRepo) CreateTransaction(ctx context.Context, transaction *model.Transaction, accountVersion uint64) error <span class="cov0" title="0">{
        return r.resources.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                account, err := r.lockAndFetchAccount(ctx, tx, transaction.AccountID, accountVersion)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return r.createTransaction(ctx, tx, transaction, account)</span>
        })
}

// PerformExchange performs a transaction exchange between two accounts
func (r *transactionRepo) PerformExchange(ctx context.Context, from *ExchangeRequest, to *ExchangeRequest) error <span class="cov0" title="0">{
        return r.resources.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                fromAccount, err := r.lockAndFetchAccount(ctx, tx, from.Transaction.AccountID, from.AccountVersion)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := r.createTransaction(ctx, tx, from.Transaction, fromAccount); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">toAccount, err := r.lockAndFetchAccount(ctx, tx, to.Transaction.AccountID, to.AccountVersion)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return r.createTransaction(ctx, tx, to.Transaction, toAccount)</span>
        })
}

// createTransaction handles the actual transaction creation logic
func (r *transactionRepo) createTransaction(ctx context.Context, tx *gorm.DB, transaction *model.Transaction, account *model.Account) error <span class="cov0" title="0">{
        // Check if account has sufficient balance for debit transactions
        if transaction.Type == model.TransactionTypeDebit &amp;&amp; account.Balance &lt; transaction.Amount </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Insufficient balance", logger.Field("account", account), logger.Field("transaction", transaction))
                return errs.NewPaymentRequiredError("insufficient balance", "INSUFFICIENT_BALANCE", nil)
        }</span>

        <span class="cov0" title="0">transaction.PreviousBalance = account.Balance
        switch transaction.Type </span>{
        case model.TransactionTypeDebit:<span class="cov0" title="0">
                account.Balance -= transaction.Amount
                if err := r.applyDebitFIFO(ctx, tx, transaction); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case model.TransactionTypeCredit:<span class="cov0" title="0">
                account.Balance += transaction.Amount
                transaction.AvailableAmount = transaction.Amount</span>
        }

        <span class="cov0" title="0">account.Version++
        transaction.NewBalance = account.Balance
        transaction.Version = account.Version

        // Generate transaction ID
        if err := tx.Raw("SELECT generate_transaction_id();").Scan(&amp;transaction.ID).Error; err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Error generating transaction ID", logger.Field("error", err))
                return err
        }</span>

        // Create transaction and update account balance
        <span class="cov0" title="0">if err := tx.Create(transaction).Error; err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Error creating transaction", logger.Field("error", err))
                return err
        }</span>
        <span class="cov0" title="0">if err := tx.Save(&amp;account).Error; err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Error saving account", logger.Field("error", err))
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// lockAndFetchAccount locks and retrieves an account by ID with version checking for optimistic concurrency
func (r *transactionRepo) lockAndFetchAccount(ctx context.Context, tx *gorm.DB, accountId string, accountVersion uint64) (*model.Account, error) <span class="cov0" title="0">{
        var account model.Account
        if err := tx.Clauses(clause.Locking{Strength: "UPDATE"}).Where("id = ?", accountId).First(&amp;account).Error; err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Error fetching account by ID", logger.Field("error", err), logger.Field("accountId", accountId))
                return nil, err
        }</span>
        // Check for version conflicts (optimistic locking)
        <span class="cov0" title="0">if account.Version != accountVersion </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Account version conflict", logger.Field("account", account), logger.Field("accountVersion", accountVersion))
                return nil, errs.NewConflictError(fmt.Sprintf("Account %s has been modified by another transaction", accountId), "ACCOUNT_VERSION_MODIFIED", nil)
        }</span>
        <span class="cov0" title="0">return &amp;account, nil</span>
}

// applyDebitFIFO applies FIFO (first-in, first-out) logic for debiting transactions from available balance
func (r *transactionRepo) applyDebitFIFO(ctx context.Context, tx *gorm.DB, transaction *model.Transaction) error <span class="cov0" title="0">{
        var transactions []model.Transaction
        var modifiedTransactions []model.Transaction

        err := tx.Clauses(clause.Locking{Strength: "UPDATE"}).
                Where("account_id = ? AND type = 'CREDIT' AND available_amount &gt; 0", transaction.AccountID).
                Order("created_at asc").Find(&amp;transactions).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Error fetching credit transactions", logger.Field("error", err))
                return err
        }</span>

        <span class="cov0" title="0">amount := transaction.Amount
        for _, t := range transactions </span><span class="cov0" title="0">{
                modifiedTransactions = append(modifiedTransactions, t)
                if t.AvailableAmount &gt;= amount </span><span class="cov0" title="0">{
                        t.AvailableAmount -= amount
                        amount = 0
                        break</span>
                } else<span class="cov0" title="0"> {
                        amount -= t.AvailableAmount
                        t.AvailableAmount = 0
                }</span>
        }

        <span class="cov0" title="0">if amount &gt; 0 </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Insufficient balance for debit", logger.Field("account_id", transaction.AccountID))
                return errs.NewPaymentRequiredError("insufficient balance", "INSUFFICIENT_BALANCE", nil)
        }</span>

        <span class="cov0" title="0">if len(modifiedTransactions) &gt; 0 </span><span class="cov0" title="0">{
                if err := tx.Save(&amp;modifiedTransactions).Error; err != nil </span><span class="cov0" title="0">{
                        api.GetLogger(ctx).Error("Error saving modified transactions", logger.Field("error", err))
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package repository

import (
        "context"
        "github.com/IBM/sarama"
        "github.com/abdelrahman146/digital-wallet/internal/model"
        "github.com/abdelrahman146/digital-wallet/internal/resource"
        "github.com/abdelrahman146/digital-wallet/pkg/api"
        "github.com/abdelrahman146/digital-wallet/pkg/logger"
        "gorm.io/gorm"
)

type TriggerRepo interface {
        // CreateTrigger creates a new trigger
        CreateTrigger(ctx context.Context, trigger *model.Trigger) error
        // UpdateTrigger updates an existing trigger
        UpdateTrigger(ctx context.Context, trigger *model.Trigger) error
        // DeleteTrigger deletes a trigger
        DeleteTrigger(ctx context.Context, trigger *model.Trigger) error
        // FetchTriggerByID retrieves a trigger by its ID
        FetchTriggerByID(ctx context.Context, id uint64) (*model.Trigger, error)
        // FetchTriggerBySlug retrieves a trigger by its slug
        FetchTriggerBySlug(ctx context.Context, slug string) (*model.Trigger, error)
        // FetchTriggers retrieves a paginated list of triggers
        FetchTriggers(ctx context.Context, page int, limit int) ([]model.Trigger, error)
        // CountTriggers retrieves the total number of triggers
        CountTriggers(ctx context.Context) (int64, error)
}

type triggerRepo struct {
        resources *resource.Resources
}

// NewTriggerRepo initializes the trigger repository
func NewTriggerRepo(resources *resource.Resources) TriggerRepo <span class="cov0" title="0">{
        return &amp;triggerRepo{resources: resources}
}</span>

// CreateTrigger creates a new trigger in the database
func (r *triggerRepo) CreateTrigger(ctx context.Context, trigger *model.Trigger) error <span class="cov0" title="0">{
        if err := r.resources.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                if err := tx.Create(trigger).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">topicDetail := sarama.TopicDetail{
                        NumPartitions:     1,
                        ReplicationFactor: 1,
                }
                if err := r.resources.Broker.CreateTopic(ctx, trigger.Slug, topicDetail); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }); err != nil <span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to create trigger", logger.Field("error", err), logger.Field("trigger", trigger))
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateTrigger updates an existing trigger in the database
func (r *triggerRepo) UpdateTrigger(ctx context.Context, trigger *model.Trigger) error <span class="cov0" title="0">{
        // TODO: if slug is changed then update the topic name in broker
        if err := r.resources.DB.Save(trigger).Error; err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to update trigger", logger.Field("error", err), logger.Field("trigger", trigger))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteTrigger deletes a trigger from the database
func (r *triggerRepo) DeleteTrigger(ctx context.Context, trigger *model.Trigger) error <span class="cov0" title="0">{
        if err := r.resources.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                if err := tx.Delete(trigger).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := r.resources.Broker.DeleteTopic(ctx, trigger.Slug); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }); err != nil <span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to delete trigger", logger.Field("error", err), logger.Field("trigger", trigger))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// FetchTriggerByID retrieves a trigger by its ID
func (r *triggerRepo) FetchTriggerByID(ctx context.Context, id uint64) (*model.Trigger, error) <span class="cov0" title="0">{
        var trigger model.Trigger
        err := r.resources.DB.Where("id = ?", id).First(&amp;trigger).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to retrieve trigger by ID", logger.Field("error", err), logger.Field("triggerId", id))
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;trigger, nil</span>
}

// FetchTriggerBySlug retrieves a trigger by its slug
func (r *triggerRepo) FetchTriggerBySlug(ctx context.Context, slug string) (*model.Trigger, error) <span class="cov0" title="0">{
        var trigger model.Trigger
        err := r.resources.DB.Where("slug = ?", slug).First(&amp;trigger).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to retrieve trigger by slug", logger.Field("error", err), logger.Field("triggerSlug", slug))
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;trigger, nil</span>
}

// FetchTriggers retrieves a paginated list of triggers
func (r *triggerRepo) FetchTriggers(ctx context.Context, page int, limit int) ([]model.Trigger, error) <span class="cov0" title="0">{
        var triggers []model.Trigger
        err := r.resources.DB.Order("created_at desc").Offset((page - 1) * limit).Limit(limit).Find(&amp;triggers).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to retrieve triggers", logger.Field("error", err))
                return nil, err
        }</span>
        <span class="cov0" title="0">return triggers, nil</span>
}

// CountTriggers retrieves the total number of triggers
func (r *triggerRepo) CountTriggers(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        var total int64
        err := r.resources.DB.Model(&amp;model.Trigger{}).Count(&amp;total).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to retrieve total triggers count", logger.Field("error", err))
                return 0, err
        }</span>
        <span class="cov0" title="0">return total, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package repository

import (
        "context"
        "github.com/abdelrahman146/digital-wallet/internal/model"
        "github.com/abdelrahman146/digital-wallet/internal/resource"
        "github.com/abdelrahman146/digital-wallet/pkg/api"
        "github.com/abdelrahman146/digital-wallet/pkg/logger"
)

type UserRepo interface {
        // CreateUser Creates a new user
        CreateUser(ctx context.Context, user *model.User) error
        // UpdateUserTier Sets the user's tier by user ID and tier ID
        UpdateUserTier(ctx context.Context, userId string, tierId string) error
        // DeleteUser Deletes a user by user ID
        DeleteUser(ctx context.Context, user *model.User) error
        // FetchUserByID Retrieves a user by user ID
        FetchUserByID(ctx context.Context, userId string) (*model.User, error)
        // FetchUsersByTierID Retrieves users by their tier ID with pagination
        FetchUsersByTierID(ctx context.Context, tierId string, page int, limit int) ([]model.User, error)
        // CountUsersByTierID Retrieves the total number of users in a given tier
        CountUsersByTierID(ctx context.Context, tierId string) (int64, error)
        // FetchUsers Retrieves all users with pagination
        FetchUsers(ctx context.Context, page int, limit int) ([]model.User, error)
        // CountTotalUsers Retrieves the total number of users
        CountTotalUsers(ctx context.Context) (int64, error)
}

type userRepo struct {
        resources *resource.Resources
}

// NewUserRepo initializes the user repository
func NewUserRepo(resources *resource.Resources) UserRepo <span class="cov0" title="0">{
        return &amp;userRepo{resources: resources}
}</span>

// CreateUser creates a new user in the database
func (r *userRepo) CreateUser(ctx context.Context, user *model.User) error <span class="cov0" title="0">{
        if err := r.resources.DB.Create(user).Error; err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to create user", logger.Field("error", err), logger.Field("user", user))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// FetchUserByID retrieves a user by user ID and preloads related accounts
func (r *userRepo) FetchUserByID(ctx context.Context, userId string) (*model.User, error) <span class="cov0" title="0">{
        var user model.User
        err := r.resources.DB.Where("id = ?", userId).Preload("Accounts").First(&amp;user).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to retrieve user by ID", logger.Field("error", err), logger.Field("userId", userId))
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;user, nil</span>
}

// UpdateUserTier sets the user's tier by user ID and tier ID
func (r *userRepo) UpdateUserTier(ctx context.Context, userId string, tierId string) error <span class="cov0" title="0">{
        if err := r.resources.DB.Model(&amp;model.User{}).Where("id = ?", userId).Update("tier_id", tierId).Error; err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to update user tier", logger.Field("error", err), logger.Field("userId", userId), logger.Field("tierId", tierId))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// FetchUsersByTierID retrieves users by their tier ID with pagination and preloads related accounts
func (r *userRepo) FetchUsersByTierID(ctx context.Context, tierId string, page int, limit int) ([]model.User, error) <span class="cov0" title="0">{
        var users []model.User
        err := r.resources.DB.Where("tier_id = ?", tierId).Offset((page - 1) * limit).Limit(limit).Preload("Accounts").Find(&amp;users).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to retrieve users by tier ID", logger.Field("error", err), logger.Field("tierId", tierId))
                return nil, err
        }</span>
        <span class="cov0" title="0">return users, nil</span>
}

// CountUsersByTierID retrieves the total number of users in a given tier
func (r *userRepo) CountUsersByTierID(ctx context.Context, tierId string) (int64, error) <span class="cov0" title="0">{
        var count int64
        err := r.resources.DB.Model(&amp;model.User{}).Where("tier_id = ?", tierId).Count(&amp;count).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to count users by tier ID", logger.Field("error", err), logger.Field("tierId", tierId))
                return 0, err
        }</span>
        <span class="cov0" title="0">return count, nil</span>
}

// FetchUsers retrieves all users with pagination and preloads related accounts
func (r *userRepo) FetchUsers(ctx context.Context, page int, limit int) ([]model.User, error) <span class="cov0" title="0">{
        var users []model.User
        err := r.resources.DB.Offset((page - 1) * limit).Limit(limit).Preload("Accounts").Find(&amp;users).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to retrieve users", logger.Field("error", err))
                return nil, err
        }</span>
        <span class="cov0" title="0">return users, nil</span>
}

// CountTotalUsers retrieves the total number of users
func (r *userRepo) CountTotalUsers(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        var count int64
        err := r.resources.DB.Model(&amp;model.User{}).Count(&amp;count).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to count total users", logger.Field("error", err))
                return 0, err
        }</span>
        <span class="cov0" title="0">return count, nil</span>
}

// DeleteUser deletes a user by user ID
func (r *userRepo) DeleteUser(ctx context.Context, user *model.User) error <span class="cov0" title="0">{
        if err := r.resources.DB.Delete(user).Error; err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to delete user", logger.Field("error", err), logger.Field("user", user))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package repository

import (
        "context"
        "github.com/abdelrahman146/digital-wallet/internal/model"
        "github.com/abdelrahman146/digital-wallet/internal/resource"
        "github.com/abdelrahman146/digital-wallet/pkg/api"
        "github.com/abdelrahman146/digital-wallet/pkg/logger"
)

type WalletRepo interface {
        // CreateWallet Creates a new wallet
        CreateWallet(ctx context.Context, wallet *model.Wallet) error
        // UpdateWallet Updates an existing wallet
        UpdateWallet(ctx context.Context, wallet *model.Wallet) error
        // DeleteWallet Deletes a wallet by its wallet ID
        DeleteWallet(ctx context.Context, wallet *model.Wallet) error
        // FetchWalletByID Retrieves a wallet by its wallet ID
        FetchWalletByID(ctx context.Context, walletId string) (*model.Wallet, error)
        // FetchWallets Retrieves a paginated list of wallets
        FetchWallets(ctx context.Context, page int, limit int) ([]model.Wallet, error)
        // CountTotalWallets Retrieves the total number of wallets
        CountTotalWallets(ctx context.Context) (int64, error)
}

type walletRepo struct {
        resources *resource.Resources
}

// NewWalletRepo initializes the wallet repository
func NewWalletRepo(resources *resource.Resources) WalletRepo <span class="cov0" title="0">{
        return &amp;walletRepo{resources: resources}
}</span>

// CreateWallet creates a new wallet and its associated schema
func (r *walletRepo) CreateWallet(ctx context.Context, wallet *model.Wallet) error <span class="cov0" title="0">{
        // Create the wallet in the database
        if err := r.resources.DB.Create(wallet).Error; err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to create wallet", logger.Field("error", err), logger.Field("wallet", wallet))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// FetchWalletByID retrieves a wallet by its wallet ID
func (r *walletRepo) FetchWalletByID(ctx context.Context, walletId string) (*model.Wallet, error) <span class="cov0" title="0">{
        var wallet model.Wallet
        err := r.resources.DB.Where("id = ?", walletId).First(&amp;wallet).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to fetch wallet by ID", logger.Field("error", err), logger.Field("walletId", walletId))
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;wallet, nil</span>
}

// UpdateWallet updates an existing wallet in the database
func (r *walletRepo) UpdateWallet(ctx context.Context, wallet *model.Wallet) error <span class="cov0" title="0">{
        if err := r.resources.DB.Save(wallet).Error; err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to update wallet", logger.Field("error", err), logger.Field("wallet", wallet))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// FetchWallets retrieves a paginated list of wallets from the database
func (r *walletRepo) FetchWallets(ctx context.Context, page int, limit int) ([]model.Wallet, error) <span class="cov0" title="0">{
        var wallets []model.Wallet
        err := r.resources.DB.Order("created_at desc").Offset((page - 1) * limit).Limit(limit).Find(&amp;wallets).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to fetch wallets", logger.Field("error", err))
                return nil, err
        }</span>
        <span class="cov0" title="0">return wallets, nil</span>
}

// CountTotalWallets retrieves the total number of wallets in the database
func (r *walletRepo) CountTotalWallets(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        var total int64
        err := r.resources.DB.Model(&amp;model.Wallet{}).Count(&amp;total).Error
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to count total wallets", logger.Field("error", err))
                return 0, err
        }</span>
        <span class="cov0" title="0">return total, nil</span>
}

// DeleteWallet deletes a wallet from the database by its wallet ID
func (r *walletRepo) DeleteWallet(ctx context.Context, wallet *model.Wallet) error <span class="cov0" title="0">{
        if err := r.resources.DB.Delete(wallet).Error; err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to delete wallet", logger.Field("error", err), logger.Field("wallet", wallet))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package resource

import (
        "github.com/abdelrahman146/digital-wallet/pkg/config"
        "github.com/abdelrahman146/digital-wallet/pkg/logger"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
        gormLogger "gorm.io/gorm/logger"
)

func InitDB() *gorm.DB <span class="cov0" title="0">{
        dsn := config.GetConfig().GetDbConnectionString()
        gormDB, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{
                TranslateError: true,
                Logger:         gormLogger.Default.LogMode(gormLogger.Info),
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.GetLogger().Panic("failed to connect to database", logger.Field("error", err))
        }</span>
        <span class="cov0" title="0">db, err := gormDB.DB()
        if err != nil </span><span class="cov0" title="0">{
                logger.GetLogger().Panic("failed to get database connection", logger.Field("error", err))
        }</span>
        <span class="cov0" title="0">db.SetMaxIdleConns(10)
        db.SetMaxOpenConns(100)
        return gormDB</span>
}

func CloseDB(gormDB *gorm.DB) <span class="cov0" title="0">{
        db, err := gormDB.DB()
        if err != nil </span><span class="cov0" title="0">{
                logger.GetLogger().Panic("failed to get database connection", logger.Field("error", err))
        }</span>
        <span class="cov0" title="0">err = db.Close()
        if err != nil </span><span class="cov0" title="0">{
                logger.GetLogger().Panic("failed to close database connection", logger.Field("error", err))
        }</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package resource

import (
        "context"
        "github.com/IBM/sarama"
        "github.com/abdelrahman146/digital-wallet/pkg/api"
        "github.com/abdelrahman146/digital-wallet/pkg/config"
        "github.com/abdelrahman146/digital-wallet/pkg/logger"
)

type Broker interface {
        // CreateTopic creates a new Broker topic
        CreateTopic(ctx context.Context, topicName string, topicDetail sarama.TopicDetail) error
        // DeleteTopic deletes an existing Broker topic
        DeleteTopic(ctx context.Context, topicName string) error
        // Publish sends a message to a Broker topic
        Publish(ctx context.Context, topic string, message []byte) error
        // Close closes the Broker connection
        Close()
}

func InitBroker(group string) *broker <span class="cov0" title="0">{
        s := &amp;broker{}
        s.Init(group)
        return s
}</span>

type broker struct {
        producer      sarama.SyncProducer
        consumerGroup sarama.ConsumerGroup
}

// Init initializes the Broker connection
func (s *broker) Init(group string) <span class="cov0" title="0">{
        conf := sarama.NewConfig()
        kafkaBrokers := config.GetConfig().KafkaBrokers
        conf.Producer.Return.Successes = true
        conf.Consumer.Offsets.Initial = sarama.OffsetOldest
        producer, err := sarama.NewSyncProducer([]string{kafkaBrokers}, conf)
        if err != nil </span><span class="cov0" title="0">{
                logger.GetLogger().Panic("Failed to create Broker producer", logger.Field("error", err))
        }</span>
        <span class="cov0" title="0">consumerGroup, err := sarama.NewConsumerGroup([]string{kafkaBrokers}, group, conf)
        if err != nil </span><span class="cov0" title="0">{
                logger.GetLogger().Panic("Failed to create Broker consumer group", logger.Field("error", err), logger.Field("group", group))
        }</span>
        <span class="cov0" title="0">s.producer = producer
        s.consumerGroup = consumerGroup</span>
}

// Close closes the Broker connection
func (s *broker) Close() <span class="cov0" title="0">{
        if err := s.producer.Close(); err != nil </span><span class="cov0" title="0">{
                logger.GetLogger().Panic("Failed to close Broker producer", logger.Field("error", err))
        }</span>
        <span class="cov0" title="0">if err := s.consumerGroup.Close(); err != nil </span><span class="cov0" title="0">{
                logger.GetLogger().Panic("Failed to close Broker consumer group", logger.Field("error", err))
        }</span>
}

// CreateTopic creates a new Broker topic
func (s *broker) CreateTopic(ctx context.Context, topicName string, topicDetail sarama.TopicDetail) error <span class="cov0" title="0">{
        config := sarama.NewConfig()
        admin, err := sarama.NewClusterAdmin([]string{"localhost:9092"}, config)
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to create broker cluster admin", logger.Field("error", err))
                return err
        }</span>
        <span class="cov0" title="0">defer admin.Close()
        topics, err := admin.ListTopics()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, exists := topics[topicName]; exists </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Info("Broker topic already exists", logger.Field("topic", topicName))
                return nil
        }</span>
        <span class="cov0" title="0">if err := admin.CreateTopic(topicName, &amp;topicDetail, false); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to create broker topic", logger.Field("error", err), logger.Field("topic", topicName))
                return err
        }</span>
        <span class="cov0" title="0">api.GetLogger(ctx).Info("Successfully created Broker topic", logger.Field("topic", topicName))
        return nil</span>
}

// DeleteTopic deletes an existing Broker topic
func (s *broker) DeleteTopic(ctx context.Context, topicName string) error <span class="cov0" title="0">{
        config := sarama.NewConfig()
        admin, err := sarama.NewClusterAdmin([]string{"localhost:9092"}, config)
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to create broker cluster admin", logger.Field("error", err))
                return err
        }</span>
        <span class="cov0" title="0">defer admin.Close()
        topics, err := admin.ListTopics()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, exists := topics[topicName]; !exists </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Info("Broker topic does not exist", logger.Field("topic", topicName))
                return nil
        }</span>
        <span class="cov0" title="0">if err := admin.DeleteTopic(topicName); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to delete broker topic", logger.Field("error", err), logger.Field("topic", topicName))
                return err
        }</span>
        <span class="cov0" title="0">api.GetLogger(ctx).Info("Successfully deleted Broker topic", logger.Field("topic", topicName))
        return nil</span>
}

// Publish sends a message to a Broker topic
func (s *broker) Publish(ctx context.Context, topic string, message []byte) error <span class="cov0" title="0">{
        msg := &amp;sarama.ProducerMessage{
                Topic: topic,
                Value: sarama.ByteEncoder(message),
        }
        partition, offset, err := s.producer.SendMessage(msg)
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Failed to send message", logger.Field("error", err))
                return err
        }</span>
        <span class="cov0" title="0">api.GetLogger(ctx).Info("Successfully sent message", logger.Field("topic", topic), logger.Field("message", message), logger.Field("partition", partition), logger.Field("offset", offset))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package service

import (
        "context"
        "fmt"
        "github.com/abdelrahman146/digital-wallet/internal/model"
        "github.com/abdelrahman146/digital-wallet/internal/repository"
        "github.com/abdelrahman146/digital-wallet/pkg/api"
        "github.com/abdelrahman146/digital-wallet/pkg/errs"
        "github.com/abdelrahman146/digital-wallet/pkg/logger"
)

type AccountService interface {
        // CreateAccount creates a new account for a user
        CreateAccount(ctx context.Context, walletId, userId string) (*model.Account, error)
        // GetAccount fetches an account by ID
        GetAccount(ctx context.Context, accountId string) (*model.Account, error)
        // GetWalletAccounts fetches all accounts for a wallet
        GetWalletAccounts(ctx context.Context, walletId string, page int, limit int) (*api.List[model.Account], error)
        // GetWalletAccountsSum fetches the sum of all accounts for a wallet
        GetWalletAccountsSum(ctx context.Context, walletId string) (uint64, error)
        // DeleteAccount deletes an account by ID
        DeleteAccount(ctx context.Context, accountId string) error
}

type accountService struct {
        repos *repository.Repos
}

func NewAccountService(repos *repository.Repos) AccountService <span class="cov0" title="0">{
        return &amp;accountService{repos: repos}
}</span>

func (s *accountService) CreateAccount(ctx context.Context, walletId, userId string) (*model.Account, error) <span class="cov0" title="0">{
        user, err := s.repos.User.FetchUserByID(ctx, userId)
        if user == nil </span><span class="cov0" title="0">{
                return nil, errs.NewNotFoundError("User not found", "USER_NOT_FOUND", err)
        }</span>
        <span class="cov0" title="0">if err := api.IsAuthorizedUser(ctx, user.ID); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("User not authorized", logger.Field("userId", user.ID))
                return nil, err
        }</span>
        <span class="cov0" title="0">wallet, err := s.repos.Wallet.FetchWalletByID(ctx, walletId)
        if wallet == nil </span><span class="cov0" title="0">{
                return nil, errs.NewNotFoundError("Wallet not found", "WALLET_NOT_FOUND", err)
        }</span>
        <span class="cov0" title="0">account := &amp;model.Account{
                UserID: userId,
        }
        account.SetActor(api.GetActor(ctx), api.GetActorID(ctx))
        account.SetRemarks(fmt.Sprintf("Account created for user %s", userId))
        err = s.repos.Account.CreateAccount(ctx, account)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return account, nil</span>
}

func (s *accountService) GetAccount(ctx context.Context, accountId string) (*model.Account, error) <span class="cov0" title="0">{
        account, err := s.repos.Account.FetchAccountByID(ctx, accountId)
        if account == nil </span><span class="cov0" title="0">{
                return nil, errs.NewNotFoundError("Account not found", "ACCOUNT_NOT_FOUND", err)
        }</span>
        <span class="cov0" title="0">if err := api.IsAuthorizedUser(ctx, account.UserID); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("User not authorized", logger.Field("userId", account.UserID))
                return nil, err
        }</span>
        <span class="cov0" title="0">return account, nil</span>
}

func (s *accountService) GetWalletAccountsSum(ctx context.Context, walletId string) (uint64, error) <span class="cov0" title="0">{
        if err := api.IsAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("User not authorized")
                return 0, err
        }</span>
        <span class="cov0" title="0">wallet, err := s.repos.Wallet.FetchWalletByID(ctx, walletId)
        if wallet == nil </span><span class="cov0" title="0">{
                return 0, errs.NewNotFoundError("Wallet not found", "WALLET_NOT_FOUND", err)
        }</span>
        <span class="cov0" title="0">sum, err := s.repos.Account.SumWalletAccounts(ctx, wallet.ID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return sum, nil</span>
}

func (s *accountService) GetWalletAccounts(ctx context.Context, walletId string, page int, limit int) (*api.List[model.Account], error) <span class="cov0" title="0">{
        if err := api.IsAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("User not authorized")
                return nil, err
        }</span>
        <span class="cov0" title="0">wallet, err := s.repos.Wallet.FetchWalletByID(ctx, walletId)
        if wallet == nil </span><span class="cov0" title="0">{
                return nil, errs.NewNotFoundError("Wallet not found", "WALLET_NOT_FOUND", err)
        }</span>
        <span class="cov0" title="0">accounts, err := s.repos.Account.FetchWalletAccounts(ctx, wallet.ID, page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">total, err := s.repos.Account.CountWalletAccounts(ctx, wallet.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;api.List[model.Account]{Items: accounts, Page: page, Limit: limit, Total: total}, nil</span>
}

func (s *accountService) DeleteAccount(ctx context.Context, accountId string) error <span class="cov0" title="0">{
        if err := api.IsAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("User not authorized")
                return err
        }</span>
        <span class="cov0" title="0">account, err := s.repos.Account.FetchAccountByID(ctx, accountId)
        if account == nil </span><span class="cov0" title="0">{
                return errs.NewNotFoundError("Account not found", "ACCOUNT_NOT_FOUND", err)
        }</span>
        <span class="cov0" title="0">account.SetActor(api.GetActor(ctx), api.GetActorID(ctx))
        account.SetRemarks("Account deleted")
        account.SetOldRecord(account)
        return s.repos.Account.DeleteAccount(ctx, account)</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package service

import (
        "context"
        "github.com/abdelrahman146/digital-wallet/internal/model"
        "github.com/abdelrahman146/digital-wallet/internal/repository"
        "github.com/abdelrahman146/digital-wallet/pkg/api"
)

type AuditService interface {
        // GetTableAuditLogs retrieves a paginated list of audit logs for a table
        GetTableAuditLogs(ctx context.Context, tableName string, page int, limit int) (*api.List[model.Audit], error)
        // GetRecordAuditLogs retrieves a paginated list of audit logs for a record
        GetRecordAuditLogs(ctx context.Context, tableName, recordId string, page int, limit int) (*api.List[model.Audit], error)
        // GetActorAuditLogs retrieves a paginated list of audit logs for an actor
        GetActorAuditLogs(ctx context.Context, actor, actorId string, page int, limit int) (*api.List[model.Audit], error)
}

type auditService struct {
        repos *repository.Repos
}

func NewAuditService(repos *repository.Repos) AuditService <span class="cov0" title="0">{
        return &amp;auditService{repos: repos}
}</span>

func (s *auditService) GetTableAuditLogs(ctx context.Context, tableName string, page int, limit int) (*api.List[model.Audit], error) <span class="cov0" title="0">{
        if err := api.IsAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("User not authorized")
                return nil, err
        }</span>
        <span class="cov0" title="0">audits, err := s.repos.Audit.FetchTableAuditLogs(ctx, tableName, page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">total, err := s.repos.Audit.CountTableAuditLogs(ctx, tableName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;api.List[model.Audit]{Items: audits, Page: page, Limit: limit, Total: total}, nil</span>
}

func (s *auditService) GetRecordAuditLogs(ctx context.Context, tableName, recordId string, page int, limit int) (*api.List[model.Audit], error) <span class="cov0" title="0">{
        if err := api.IsAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("User not authorized")
                return nil, err
        }</span>
        <span class="cov0" title="0">audits, err := s.repos.Audit.FetchRecordAuditLogs(ctx, tableName, recordId, page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">total, err := s.repos.Audit.CountRecordAuditLogs(ctx, tableName, recordId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;api.List[model.Audit]{Items: audits, Page: page, Limit: limit, Total: total}, nil</span>
}

func (s *auditService) GetActorAuditLogs(ctx context.Context, actor, actorId string, page int, limit int) (*api.List[model.Audit], error) <span class="cov0" title="0">{
        if err := api.IsAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("User not authorized")
                return nil, err
        }</span>
        <span class="cov0" title="0">audits, err := s.repos.Audit.FetchActorAuditLogs(ctx, actor, actorId, page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">total, err := s.repos.Audit.CountActorAuditLogs(ctx, actor, actorId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;api.List[model.Audit]{Items: audits, Page: page, Limit: limit, Total: total}, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package service

func EvaluateProgramCondition(data map[string]interface{}, condition map[string]interface{}) (bool, error) <span class="cov0" title="0">{

        return true, nil
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package service

import (
        "context"
        "github.com/abdelrahman146/digital-wallet/internal/model"
        "github.com/abdelrahman146/digital-wallet/internal/repository"
        "github.com/abdelrahman146/digital-wallet/pkg/api"
        "github.com/abdelrahman146/digital-wallet/pkg/errs"
        "github.com/abdelrahman146/digital-wallet/pkg/logger"
        "github.com/shopspring/decimal"
)

type ExchangeRateService interface {
        // CreateExchangeRate creates a new exchange rate
        CreateExchangeRate(ctx context.Context, req *CreateExchangeRateRequest) (*model.ExchangeRate, error)
        // GetExchangeRates fetches all exchange rates
        GetExchangeRates(ctx context.Context, page int, limit int) (*api.List[model.ExchangeRate], error)
        // GetExchangeRatesByWalletID fetches all exchange rates for a wallet
        GetExchangeRatesByWalletID(ctx context.Context, walletId string, page int, limit int) (*api.List[model.ExchangeRate], error)
        // UpdateExchangeRate updates an exchange rate
        UpdateExchangeRate(ctx context.Context, exchangeRateId string, exchangeRate decimal.Decimal) (*model.ExchangeRate, error)
        // DeleteExchangeRate deletes an exchange rate
        DeleteExchangeRate(ctx context.Context, exchangeRateId string) error
}

type exchangeRateService struct {
        repos *repository.Repos
}

func NewExchangeRateService(repos *repository.Repos) ExchangeRateService <span class="cov0" title="0">{
        return &amp;exchangeRateService{repos: repos}
}</span>

func (s *exchangeRateService) CreateExchangeRate(ctx context.Context, req *CreateExchangeRateRequest) (*model.ExchangeRate, error) <span class="cov0" title="0">{
        if err := api.IsAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("User not authorized")
                return nil, err
        }</span>
        <span class="cov0" title="0">exchangeRate := &amp;model.ExchangeRate{
                FromWalletID: req.FromWalletID,
                ToWalletID:   req.ToWalletID,
                TierID:       req.TierID,
                ExchangeRate: req.ExchangeRate,
        }
        exchangeRate.SetActor(api.GetActor(ctx), api.GetActorID(ctx))
        exchangeRate.SetRemarks("Exchange rate created")
        if err := s.repos.ExchangeRate.CreateExchangeRate(ctx, exchangeRate); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return exchangeRate, nil</span>
}

func (s *exchangeRateService) GetExchangeRates(ctx context.Context, page int, limit int) (*api.List[model.ExchangeRate], error) <span class="cov0" title="0">{
        if err := api.IsAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("User not authorized")
                return nil, err
        }</span>
        <span class="cov0" title="0">exchangeRates, err := s.repos.ExchangeRate.FetchExchangeRates(ctx, page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">total, err := s.repos.ExchangeRate.CountExchangeRates(ctx)
        return &amp;api.List[model.ExchangeRate]{Items: exchangeRates, Total: total, Page: page, Limit: limit}, nil</span>
}

func (s *exchangeRateService) GetExchangeRatesByWalletID(ctx context.Context, walletId string, page int, limit int) (*api.List[model.ExchangeRate], error) <span class="cov0" title="0">{
        if err := api.IsAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("User not authorized")
                return nil, err
        }</span>
        <span class="cov0" title="0">exchangeRates, err := s.repos.ExchangeRate.FetchWalletExchangeRates(ctx, walletId, page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">total, err := s.repos.ExchangeRate.CountWalletExchangeRates(ctx, walletId)
        return &amp;api.List[model.ExchangeRate]{Items: exchangeRates, Total: total, Page: page, Limit: limit}, nil</span>
}

func (s *exchangeRateService) UpdateExchangeRate(ctx context.Context, exchangeRateId string, newRate decimal.Decimal) (*model.ExchangeRate, error) <span class="cov0" title="0">{
        if err := api.IsAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("User not authorized")
                return nil, err
        }</span>
        <span class="cov0" title="0">exchangeRate, err := s.repos.ExchangeRate.FetchExchangeRateByID(ctx, exchangeRateId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">exchangeRate.SetActor(api.GetActor(ctx), api.GetActorID(ctx))
        exchangeRate.SetRemarks("Exchange rate updated")
        exchangeRate.SetOldRecord(*exchangeRate)
        exchangeRate.ExchangeRate = newRate
        if err := s.repos.ExchangeRate.UpdateExchangeRate(ctx, exchangeRate); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return exchangeRate, nil</span>
}

func (s *exchangeRateService) DeleteExchangeRate(ctx context.Context, exchangeRateId string) error <span class="cov0" title="0">{
        if err := api.IsAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">exchangeRate, err := s.repos.ExchangeRate.FetchExchangeRateByID(ctx, exchangeRateId)
        if exchangeRate == nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Exchange Rate not found", logger.Field("exchangeRateId", exchangeRateId))
                return errs.NewNotFoundError("Exchange Rate not found", "EXCHANGE_RATE_NOT_FOUND", err)
        }</span>
        <span class="cov0" title="0">exchangeRate.SetActor(api.GetActor(ctx), api.GetActorID(ctx))
        exchangeRate.SetRemarks("Exchange rate deleted")
        exchangeRate.SetOldRecord(exchangeRate)
        return s.repos.ExchangeRate.DeleteExchangeRate(ctx, exchangeRate)</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package service

import (
        "context"
        "github.com/abdelrahman146/digital-wallet/internal/model"
        "github.com/abdelrahman146/digital-wallet/internal/repository"
        "github.com/abdelrahman146/digital-wallet/pkg/api"
        "github.com/abdelrahman146/digital-wallet/pkg/errs"
        "github.com/abdelrahman146/digital-wallet/pkg/logger"
)

type ProgramService interface {
        CreateProgram(ctx context.Context, req CreateProgramRequest) (*model.Program, error)
        UpdateProgram(ctx context.Context, id uint64, req UpdateProgramRequest) (*model.Program, error)
        DeleteProgram(ctx context.Context, id uint64) error
        GetProgram(ctx context.Context, id uint64) (*model.Program, error)
        ListPrograms(ctx context.Context, page, limit int) (*api.List[model.Program], error)
}

type programService struct {
        repos *repository.Repos
}

func NewProgramService(repos *repository.Repos) ProgramService <span class="cov0" title="0">{
        return &amp;programService{repos: repos}
}</span>

func (s *programService) CreateProgram(ctx context.Context, req CreateProgramRequest) (*model.Program, error) <span class="cov0" title="0">{
        if err := api.IsAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Unauthorized access", logger.Field("error", err))
                return nil, err
        }</span>
        <span class="cov0" title="0">program := &amp;model.Program{
                Name:         req.Name,
                WalletID:     req.WalletID,
                TriggerSlug:  req.TriggerSlug,
                Condition:    req.Condition,
                Effect:       req.Effect,
                ValidFrom:    req.ValidFrom,
                ValidUntil:   req.ValidUntil,
                IsActive:     req.IsActive,
                LimitPerUser: req.LimitPerUser,
        }
        program.SetActor(api.GetActor(ctx), api.GetActorID(ctx))
        program.SetRemarks("Program created")
        if err := s.repos.Program.CreateProgram(ctx, program); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return program, nil</span>
}

func (s *programService) UpdateProgram(ctx context.Context, id uint64, req UpdateProgramRequest) (*model.Program, error) <span class="cov0" title="0">{
        if err := api.IsAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Unauthorized access", logger.Field("error", err))
                return nil, err
        }</span>
        <span class="cov0" title="0">program, err := s.repos.Program.FetchProgramByID(ctx, id)
        if program == nil </span><span class="cov0" title="0">{
                return nil, errs.NewNotFoundError("Program not found", "PROGRAM_NOT_FOUND", err)
        }</span>
        <span class="cov0" title="0">program.SetOldRecord(*program)
        if req.Name != nil </span><span class="cov0" title="0">{
                program.Name = *req.Name
        }</span>
        <span class="cov0" title="0">if req.WalletID != nil </span><span class="cov0" title="0">{
                program.WalletID = *req.WalletID
        }</span>
        <span class="cov0" title="0">if req.TriggerSlug != nil </span><span class="cov0" title="0">{
                program.TriggerSlug = *req.TriggerSlug
        }</span>
        <span class="cov0" title="0">if req.Condition != nil </span><span class="cov0" title="0">{
                program.Condition = *req.Condition
        }</span>
        <span class="cov0" title="0">if req.Effect != nil </span><span class="cov0" title="0">{
                program.Effect = *req.Effect
        }</span>
        <span class="cov0" title="0">if req.ValidFrom != nil </span><span class="cov0" title="0">{
                program.ValidFrom = *req.ValidFrom
        }</span>
        <span class="cov0" title="0">if req.ValidUntil != nil </span><span class="cov0" title="0">{
                program.ValidUntil = req.ValidUntil
        }</span>
        <span class="cov0" title="0">if req.IsActive != nil </span><span class="cov0" title="0">{
                program.IsActive = *req.IsActive
        }</span>
        <span class="cov0" title="0">if req.LimitPerUser != nil </span><span class="cov0" title="0">{
                program.LimitPerUser = req.LimitPerUser
        }</span>
        <span class="cov0" title="0">program.SetActor(api.GetActor(ctx), api.GetActorID(ctx))
        program.SetRemarks("Program updated")
        if err := s.repos.Program.UpdateProgram(ctx, program); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return program, nil</span>
}

func (s *programService) DeleteProgram(ctx context.Context, id uint64) error <span class="cov0" title="0">{
        if err := api.IsAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Unauthorized access", logger.Field("error", err))
                return err
        }</span>
        <span class="cov0" title="0">program, err := s.repos.Program.FetchProgramByID(ctx, id)
        if program == nil </span><span class="cov0" title="0">{
                return errs.NewNotFoundError("Program not found", "PROGRAM_NOT_FOUND", err)
        }</span>
        <span class="cov0" title="0">if err := s.repos.Program.DeleteProgram(ctx, program); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *programService) GetProgram(ctx context.Context, id uint64) (*model.Program, error) <span class="cov0" title="0">{
        if err := api.IsAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Unauthorized access", logger.Field("error", err))
                return nil, err
        }</span>
        <span class="cov0" title="0">program, err := s.repos.Program.FetchProgramByID(ctx, id)
        if program == nil </span><span class="cov0" title="0">{
                return nil, errs.NewNotFoundError("Program not found", "PROGRAM_NOT_FOUND", err)
        }</span>
        <span class="cov0" title="0">return program, nil</span>
}

func (s *programService) ListPrograms(ctx context.Context, page, limit int) (*api.List[model.Program], error) <span class="cov0" title="0">{
        if err := api.IsAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Unauthorized access", logger.Field("error", err))
                return nil, err
        }</span>
        <span class="cov0" title="0">programs, err := s.repos.Program.FetchPrograms(ctx, page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">count, err := s.repos.Program.CountPrograms(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;api.List[model.Program]{Items: programs, Limit: limit, Page: page, Total: count}, nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package service

import (
        "context"
        "github.com/abdelrahman146/digital-wallet/internal/model"
        "github.com/abdelrahman146/digital-wallet/internal/repository"
        "github.com/abdelrahman146/digital-wallet/pkg/api"
        "github.com/abdelrahman146/digital-wallet/pkg/errs"
        "github.com/abdelrahman146/digital-wallet/pkg/validator"
)

type TierService interface {
        CreateTier(ctx context.Context, req *CreateTierRequest) (*model.Tier, error)
        GetTierByID(ctx context.Context, tierId string) (*model.Tier, error)
        GetTiers(ctx context.Context, page int, limit int) (*api.List[model.Tier], error)
        DeleteTier(ctx context.Context, tierId string) error
}

type tierService struct {
        repos *repository.Repos
}

func NewTierService(repos *repository.Repos) TierService <span class="cov0" title="0">{
        return &amp;tierService{repos: repos}
}</span>

func (s *tierService) CreateTier(ctx context.Context, req *CreateTierRequest) (*model.Tier, error) <span class="cov0" title="0">{
        if err := api.IsAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("User not authorized")
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := validator.GetValidator().ValidateStruct(req); err != nil </span><span class="cov0" title="0">{
                fields := validator.GetValidator().GetValidationErrors(err)
                return nil, errs.NewValidationError("Invalid tier request", "", fields)
        }</span>
        <span class="cov0" title="0">tier := &amp;model.Tier{
                ID:   req.ID,
                Name: req.Name,
        }
        tier.SetActor(api.GetActor(ctx), api.GetActorID(ctx))
        tier.SetRemarks("Tier created")
        if err := s.repos.Tier.CreateTier(ctx, tier); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return tier, nil</span>
}

func (s *tierService) GetTierByID(ctx context.Context, tierId string) (*model.Tier, error) <span class="cov0" title="0">{
        tier, err := s.repos.Tier.FetchTierByID(ctx, tierId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return tier, nil</span>
}

func (s *tierService) GetTiers(ctx context.Context, page int, limit int) (*api.List[model.Tier], error) <span class="cov0" title="0">{
        tiers, err := s.repos.Tier.FetchTiers(ctx, page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">total, err := s.repos.Tier.CountTiers(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;api.List[model.Tier]{Items: tiers, Total: total, Page: page, Limit: limit}, nil</span>
}

func (s *tierService) DeleteTier(ctx context.Context, tierId string) error <span class="cov0" title="0">{
        if err := api.IsAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("User not authorized")
                return err
        }</span>
        <span class="cov0" title="0">tier, err := s.repos.Tier.FetchTierByID(ctx, tierId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">tier.SetActor(api.GetActor(ctx), api.GetActorID(ctx))
        tier.SetRemarks("Tier deleted")
        tier.SetOldRecord(tier)
        return s.repos.Tier.DeleteTier(ctx, tier)</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package service

import (
        "context"
        "github.com/abdelrahman146/digital-wallet/internal/model"
        "github.com/abdelrahman146/digital-wallet/internal/repository"
        "github.com/abdelrahman146/digital-wallet/pkg/api"
        "github.com/abdelrahman146/digital-wallet/pkg/errs"
        "github.com/abdelrahman146/digital-wallet/pkg/logger"
        "github.com/abdelrahman146/digital-wallet/pkg/types"
        "github.com/abdelrahman146/digital-wallet/pkg/validator"
        "github.com/shopspring/decimal"
        "time"
)

type TransactionService interface {
        // CreateTransaction creates a transaction
        CreateTransaction(ctx context.Context, walletId, accountId string, req *TransactionRequest) (*model.Transaction, error)
        // Exchange exchanges between two accounts for the same user
        Exchange(ctx context.Context, fromWalletId, toWalletId, userId string, amount uint64) (*ExchangeResponse, error)
        // GetAccountTransactions returns a list of transactions for an account
        GetAccountTransactions(ctx context.Context, walletId, accountId string, page int, limit int) (*api.List[model.Transaction], error)
        // GetAccountTransactionSum returns the sum of transactions for an account
        GetAccountTransactionSum(ctx context.Context, walletId, accountId string) (uint64, error)
        // GetWalletTransactions returns a list of transactions for a wallet
        GetWalletTransactions(ctx context.Context, walletId string, page int, limit int) (*api.List[model.Transaction], error)
        // GetWalletTransactionSum returns the sum of transactions for a wallet
        GetWalletTransactionSum(ctx context.Context, walletId string) (uint64, error)
        // GetAccountExpiringTransactionsSum returns the sum of expiring transactions for an account
        GetAccountExpiringTransactionsSum(ctx context.Context, accountId string) (uint64, error)
        // GetExpiredWalletTransactions returns a list of expired transactions for a wallet
        GetExpiredWalletTransactions(ctx context.Context, walletId string) ([]model.Transaction, error)
}

type transactionService struct {
        repos *repository.Repos
}

func NewTransactionService(repos *repository.Repos) TransactionService <span class="cov0" title="0">{
        return &amp;transactionService{repos: repos}
}</span>

func (s *transactionService) CreateTransaction(ctx context.Context, walletId, accountId string, req *TransactionRequest) (*model.Transaction, error) <span class="cov0" title="0">{
        if err := validator.GetValidator().ValidateStruct(req); err != nil </span><span class="cov0" title="0">{
                fields := validator.GetValidator().GetValidationErrors(err)
                api.GetLogger(ctx).Error("Invalid transaction request", logger.Field("fields", fields), logger.Field("request", req))
                return nil, errs.NewValidationError("Invalid transaction request", "", fields)
        }</span>
        <span class="cov0" title="0">wallet, err := s.repos.Wallet.FetchWalletByID(ctx, walletId)
        if wallet == nil </span><span class="cov0" title="0">{
                return nil, errs.NewNotFoundError("wallet not found", "WALLET_NOT_FOUND", err)
        }</span>
        <span class="cov0" title="0">account, _ := s.repos.Account.FetchAccountByID(ctx, accountId)
        if account == nil </span><span class="cov0" title="0">{
                return nil, errs.NewNotFoundError("Account not found", "ACCOUNT_NOT_FOUND", err)
        }</span>
        <span class="cov0" title="0">if err := api.IsAuthorizedUser(ctx, account.UserID); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Unauthorized", logger.Field("userId", account.UserID))
                return nil, err
        }</span>
        <span class="cov0" title="0">transaction := &amp;model.Transaction{
                AccountID: accountId,
                WalletID:  walletId,
                Amount:    req.Amount,
                Reason:    req.Reason,
                Type:      req.Type,
                Metadata:  req.Metadata,
                ProgramID: req.ProgramID,
        }
        transaction.SetActor(api.GetActor(ctx), api.GetActorID(ctx))
        transaction.SetRemarks("Transaction created")
        if req.Type == model.TransactionTypeCredit &amp;&amp; wallet.PointsExpireAfter != nil </span><span class="cov0" title="0">{
                expireAt := time.Now().Add(wallet.PointsExpireAfter.Duration())
                transaction.ExpireAt = &amp;expireAt
        }</span>
        <span class="cov0" title="0">if err := s.repos.Transaction.CreateTransaction(ctx, transaction, account.Version); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return transaction, nil</span>
}

func (s *transactionService) Exchange(ctx context.Context, fromWalletId, toWalletId, userId string, amount uint64) (*ExchangeResponse, error) <span class="cov0" title="0">{
        // Get User
        user, err := s.repos.User.FetchUserByID(ctx, userId)
        if user == nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("User not found", logger.Field("userId", userId))
                return nil, errs.NewNotFoundError("User not found", "USER_NOT_FOUND", err)
        }</span>

        // Check if user is authorized
        <span class="cov0" title="0">if err := api.IsAuthorizedUser(ctx, userId); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("User not authorized", logger.Field("userId", userId))
                return nil, err
        }</span>

        // Get Wallets
        <span class="cov0" title="0">fromWallet, err := s.repos.Wallet.FetchWalletByID(ctx, fromWalletId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if fromWallet == nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("From Wallet not found", logger.Field("fromWalletId", fromWalletId))
                return nil, errs.NewNotFoundError("fromWallet not found", "FROM_WALLET_NOT_FOUND", nil)
        }</span>
        <span class="cov0" title="0">toWallet, err := s.repos.Wallet.FetchWalletByID(ctx, toWalletId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if toWallet == nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("To Wallet not found", logger.Field("toWalletId", toWalletId))
                return nil, errs.NewNotFoundError("toWallet not found", "TO_WALLET_NOT_FOUND", nil)
        }</span>

        // Get Exchange Rate
        <span class="cov0" title="0">exchangeRate, err := s.repos.ExchangeRate.FetchExchangeRate(ctx, fromWalletId, toWalletId, user.TierID)
        if exchangeRate == nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Exchange Rate not found", logger.Field("fromWalletId", fromWalletId), logger.Field("toWalletId", toWalletId), logger.Field("tierId", user.TierID))
                return nil, errs.NewNotFoundError("Exchange Rate not found", "EXCHANGE_RATE_NOT_FOUND", err)
        }</span>

        // Get Accounts
        <span class="cov0" title="0">fromAccount, err := s.repos.Account.FetchAccountByUserID(ctx, fromWalletId, userId)
        if fromAccount == nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("From Account not found", logger.Field("fromWalletId", fromWalletId), logger.Field("userId", userId))
                return nil, errs.NewNotFoundError("From Account not found", "FROM_ACCOUNT_NOT_FOUND", err)
        }</span>
        <span class="cov0" title="0">toAccount, err := s.repos.Account.FetchAccountByUserID(ctx, toWalletId, userId)
        if toAccount == nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("From Account not found", logger.Field("toWalletId", fromWalletId), logger.Field("userId", userId))
                return nil, errs.NewNotFoundError("From Account not found", "TO_ACCOUNT_NOT_FOUND", err)
        }</span>

        // Check if balance is sufficient
        <span class="cov0" title="0">if amount &gt; fromAccount.Balance </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Insufficient balance", logger.Field("amount", amount), logger.Field("balance", fromAccount.Balance))
                return nil, errs.NewPaymentRequiredError("Insufficient balance", "INSUFFICIENT_BALANCE", nil)
        }</span>
        // Check toWallet limit per user is not exceeded
        <span class="cov0" title="0">if toWallet.LimitPerUser != nil &amp;&amp; amount+toAccount.Balance &gt; *toWallet.LimitPerUser </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Limit per user exceeded", logger.Field("limit", *toWallet.LimitPerUser), logger.Field("amount", amount))
                return nil, errs.NewForbiddenError("Limit per user exceeded", "LIMIT_PER_USER_EXCEEDED", nil)
        }</span>

        // Check toWallet total limit is not exceeded
        <span class="cov0" title="0">sum, err := s.repos.Account.SumWalletAccounts(ctx, toWalletId)
        if err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Error while getting wallet accounts sum", logger.Field("toWalletId", toWalletId))
                return nil, err
        }</span>
        <span class="cov0" title="0">if toWallet.LimitGlobal != nil &amp;&amp; amount+sum &gt; *toWallet.LimitGlobal </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Limit global exceeded", logger.Field("limit", *toWallet.LimitGlobal), logger.Field("totalWalletBalance", sum), logger.Field("amount", amount))
                return nil, errs.NewForbiddenError("Limit global exceeded", "LIMIT_GLOBAL_EXCEEDED", nil)
        }</span>

        // CreateTransaction From Transaction
        <span class="cov0" title="0">fromTransaction := &amp;model.Transaction{
                AccountID: fromAccount.ID,
                Amount:    amount,
                Reason:    model.TransactionReasonExchange,
                Type:      model.TransactionTypeDebit,
        }
        fromTransaction.Metadata = make(types.JSONB)
        fromTransaction.Metadata["toWalletId"] = toWalletId
        fromTransaction.Metadata["toAccountId"] = toAccount.ID
        fromTransaction.SetActor(api.GetActor(ctx), api.GetActorID(ctx))
        fromTransaction.SetRemarks("Exchange transaction created to wallet " + toWalletId)

        // Setup To Transaction
        amountToCredit := decimal.NewFromUint64(amount)
        if toWallet.IsMonetary </span><span class="cov0" title="0">{
                amountToCredit = amountToCredit.Div(decimal.NewFromInt(100))
        }</span>
        <span class="cov0" title="0">amountToCredit = amountToCredit.Mul(exchangeRate.ExchangeRate)
        if toWallet.IsMonetary </span><span class="cov0" title="0">{
                amountToCredit = amountToCredit.Mul(decimal.NewFromInt(100))
        }</span>
        <span class="cov0" title="0">toTransaction := &amp;model.Transaction{
                AccountID: toAccount.ID,
                Amount:    amountToCredit.BigInt().Uint64(),
                Type:      model.TransactionTypeCredit,
                Reason:    model.TransactionReasonExchange,
        }
        toTransaction.Metadata = make(types.JSONB)
        toTransaction.Metadata["fromWalletId"] = fromWalletId
        toTransaction.Metadata["fromAccountId"] = fromAccount.ID
        toTransaction.Metadata["ExchangedAmount"] = amount
        toTransaction.Metadata["exchangeRate"] = exchangeRate.ExchangeRate.String()
        toTransaction.SetActor(api.GetActor(ctx), api.GetActorID(ctx))
        toTransaction.SetRemarks("Exchange transaction created from wallet " + fromWalletId)

        if toWallet.PointsExpireAfter != nil </span><span class="cov0" title="0">{
                expireAt := time.Now().Add(toWallet.PointsExpireAfter.Duration())
                toTransaction.ExpireAt = &amp;expireAt
        }</span>

        <span class="cov0" title="0">from := &amp;repository.ExchangeRequest{
                WalletID:       fromWalletId,
                Transaction:    fromTransaction,
                AccountVersion: fromAccount.Version,
        }

        to := &amp;repository.ExchangeRequest{
                WalletID:       toWalletId,
                Transaction:    toTransaction,
                AccountVersion: toAccount.Version,
        }

        if err := s.repos.Transaction.PerformExchange(ctx, from, to); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">resp := &amp;ExchangeResponse{
                FromTransaction: *fromTransaction,
                ToTransaction:   *toTransaction,
        }
        return resp, nil</span>
}

func (s *transactionService) GetAccountTransactions(ctx context.Context, walletId, accountId string, page int, limit int) (*api.List[model.Transaction], error) <span class="cov0" title="0">{
        wallet, err := s.repos.Wallet.FetchWalletByID(ctx, walletId)
        if wallet == nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Wallet not found", logger.Field("walletId", walletId))
                return nil, errs.NewNotFoundError("Wallet not found", "WALLET_NOT_FOUND", err)
        }</span>
        <span class="cov0" title="0">account, err := s.repos.Account.FetchAccountByID(ctx, accountId)
        if account == nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Account not found", logger.Field("walletId", walletId), logger.Field("accountId", accountId))
                return nil, errs.NewNotFoundError("Account not found", "ACCOUNT_NOT_FOUND", err)
        }</span>
        <span class="cov0" title="0">if err := api.IsAuthorizedUser(ctx, account.UserID); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Unauthorized", logger.Field("userId", account.UserID))
                return nil, err
        }</span>
        <span class="cov0" title="0">transactions, err := s.repos.Transaction.FetchAccountTransactions(ctx, accountId, page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">total, err := s.repos.Transaction.CountAccountTransactions(ctx, accountId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;api.List[model.Transaction]{Items: transactions, Page: page, Limit: limit, Total: total}, nil</span>
}

func (s *transactionService) GetAccountTransactionSum(ctx context.Context, walletId, accountId string) (uint64, error) <span class="cov0" title="0">{
        wallet, err := s.repos.Wallet.FetchWalletByID(ctx, walletId)
        if wallet == nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Wallet not found", logger.Field("walletId", walletId))
                return 0, errs.NewNotFoundError("Wallet not found", "WALLET_NOT_FOUND", err)
        }</span>
        <span class="cov0" title="0">account, err := s.repos.Account.FetchAccountByID(ctx, accountId)
        if account == nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Account not found", logger.Field("walletId", walletId), logger.Field("accountId", accountId))
                return 0, errs.NewNotFoundError("Account not found", "ACCOUNT_NOT_FOUND", err)
        }</span>
        <span class="cov0" title="0">if err := api.IsAuthorizedUser(ctx, account.UserID); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Unauthorized", logger.Field("userId", account.UserID))
                return 0, err
        }</span>
        <span class="cov0" title="0">sum, err := s.repos.Transaction.SumAccountTransactions(ctx, accountId)
        return sum, err</span>
}

func (s *transactionService) GetWalletTransactions(ctx context.Context, walletId string, page int, limit int) (*api.List[model.Transaction], error) <span class="cov0" title="0">{
        if err := api.IsAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Unauthorized", logger.Field("actor", api.GetActor(ctx)), logger.Field("userId", api.GetActorID(ctx)))
                return nil, err
        }</span>
        <span class="cov0" title="0">wallet, err := s.repos.Wallet.FetchWalletByID(ctx, walletId)
        if wallet == nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Wallet not found", logger.Field("walletId", walletId))
                return nil, errs.NewNotFoundError("Wallet not found", "WALLET_NOT_FOUND", err)
        }</span>
        <span class="cov0" title="0">transactions, err := s.repos.Transaction.FetchWalletTransactions(ctx, walletId, page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">total, err := s.repos.Transaction.CountWalletTransactions(ctx, walletId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;api.List[model.Transaction]{Items: transactions, Page: page, Limit: limit, Total: total}, nil</span>
}

func (s *transactionService) GetWalletTransactionSum(ctx context.Context, walletId string) (uint64, error) <span class="cov0" title="0">{
        if err := api.IsAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Unauthorized", logger.Field("actor", api.GetActor(ctx)), logger.Field("userId", api.GetActorID(ctx)))
                return 0, err
        }</span>
        <span class="cov0" title="0">wallet, err := s.repos.Wallet.FetchWalletByID(ctx, walletId)
        if wallet == nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Wallet not found", logger.Field("walletId", walletId))
                return 0, errs.NewNotFoundError("Wallet not found", "WALLET_NOT_FOUND", err)
        }</span>
        <span class="cov0" title="0">sum, err := s.repos.Transaction.SumAccountTransactions(ctx, walletId)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return sum, nil</span>
}

func (s *transactionService) GetAccountExpiringTransactionsSum(ctx context.Context, accountId string) (uint64, error) <span class="cov0" title="0">{
        account, err := s.repos.Account.FetchAccountByID(ctx, accountId)
        if account == nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Account not found", logger.Field("accountId", accountId))
                return 0, errs.NewNotFoundError("Account not found", "ACCOUNT_NOT_FOUND", err)
        }</span>
        <span class="cov0" title="0">if err := api.IsAuthorizedUser(ctx, account.UserID); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Unauthorized", logger.Field("userId", account.UserID))
                return 0, err
        }</span>
        <span class="cov0" title="0">wallet, err := s.repos.Wallet.FetchWalletByID(ctx, account.WalletID)
        if wallet == nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Wallet not found", logger.Field("walletId", account.WalletID))
                return 0, errs.NewNotFoundError("Wallet not found", "WALLET_NOT_FOUND", err)
        }</span>
        <span class="cov0" title="0">if wallet.PointsExpireAfter == nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Wallet points expire after not set", logger.Field("walletId", account.WalletID))
                return 0, errs.NewBadRequestError("Wallet points expire after not set", "WALLET_POINTS_EXPIRE_AFTER_NOT_SET", nil)
        }</span>
        <span class="cov0" title="0">sum, err := s.repos.Transaction.SumExpiringAccountTransactions(ctx, accountId, *wallet.PointsExpireAfter)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return sum, nil</span>
}

func (s *transactionService) GetExpiredWalletTransactions(ctx context.Context, walletId string) ([]model.Transaction, error) <span class="cov0" title="0">{
        if err := api.IsAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Unauthorized", logger.Field("actor", api.GetActor(ctx)), logger.Field("userId", api.GetActorID(ctx)))
                return nil, err
        }</span>
        <span class="cov0" title="0">wallet, err := s.repos.Wallet.FetchWalletByID(ctx, walletId)
        if wallet == nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Wallet not found", logger.Field("walletId", walletId))
                return nil, errs.NewNotFoundError("Wallet not found", "WALLET_NOT_FOUND", err)
        }</span>
        <span class="cov0" title="0">transactions, err := s.repos.Transaction.FetchExpiredWalletTransactions(ctx, walletId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return transactions, nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package service

import (
        "context"
        "github.com/abdelrahman146/digital-wallet/internal/model"
        "github.com/abdelrahman146/digital-wallet/internal/repository"
        "github.com/abdelrahman146/digital-wallet/pkg/api"
        "github.com/abdelrahman146/digital-wallet/pkg/errs"
        "github.com/abdelrahman146/digital-wallet/pkg/logger"
        "github.com/abdelrahman146/digital-wallet/pkg/validator"
)

type TriggerService interface {
        CreateTrigger(ctx context.Context, req CreateTriggerRequest) (*model.Trigger, error)
        UpdateTrigger(ctx context.Context, triggerId uint64, req UpdateTriggerRequest) (*model.Trigger, error)
        DeleteTrigger(ctx context.Context, triggerId uint64) error
        GetTrigger(ctx context.Context, triggerId uint64) (*model.Trigger, error)
        ListTriggers(ctx context.Context, page, limit int) (*api.List[model.Trigger], error)
}

type triggerService struct {
        repos *repository.Repos
}

func NewTriggerService(repos *repository.Repos) TriggerService <span class="cov0" title="0">{
        return &amp;triggerService{repos: repos}
}</span>

func (s *triggerService) CreateTrigger(ctx context.Context, req CreateTriggerRequest) (*model.Trigger, error) <span class="cov0" title="0">{
        if err := api.IsAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Unauthorized access", logger.Field("error", err))
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := validator.GetValidator().ValidateStruct(req); err != nil </span><span class="cov0" title="0">{
                fields := validator.GetValidator().GetValidationErrors(err)
                api.GetLogger(ctx).Error("Invalid request", logger.Field("fields", fields), logger.Field("request", req))
                return nil, errs.NewValidationError("Invalid request", "", fields)
        }</span>
        <span class="cov0" title="0">trigger := &amp;model.Trigger{
                Name:       req.Name,
                Slug:       req.Slug,
                Properties: req.Properties,
        }
        trigger.SetActor(api.GetActor(ctx), api.GetActorID(ctx))
        trigger.SetRemarks("Trigger created")
        if err := s.repos.Trigger.CreateTrigger(ctx, trigger); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return trigger, nil</span>
}

func (s *triggerService) UpdateTrigger(ctx context.Context, triggerId uint64, req UpdateTriggerRequest) (*model.Trigger, error) <span class="cov0" title="0">{
        if err := api.IsAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Unauthorized access", logger.Field("error", err))
                return nil, err
        }</span>
        <span class="cov0" title="0">trigger, err := s.repos.Trigger.FetchTriggerByID(ctx, triggerId)
        if trigger == nil </span><span class="cov0" title="0">{
                return nil, errs.NewNotFoundError("Trigger not found", "TRIGGER_NOT_FOUND", err)
        }</span>
        <span class="cov0" title="0">trigger.SetActor(api.GetActor(ctx), api.GetActorID(ctx))
        trigger.SetRemarks("Trigger updated")
        trigger.SetOldRecord(*trigger)
        if req.Name != nil </span><span class="cov0" title="0">{
                trigger.Name = *req.Name
        }</span>
        <span class="cov0" title="0">if req.Slug != nil </span><span class="cov0" title="0">{
                trigger.Slug = *req.Slug
        }</span>
        <span class="cov0" title="0">if req.Properties != nil </span><span class="cov0" title="0">{
                trigger.Properties = *req.Properties
        }</span>
        <span class="cov0" title="0">if err := s.repos.Trigger.UpdateTrigger(ctx, trigger); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return trigger, nil</span>
}

func (s *triggerService) DeleteTrigger(ctx context.Context, triggerId uint64) error <span class="cov0" title="0">{
        if err := api.IsAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Unauthorized access", logger.Field("error", err))
                return err
        }</span>
        <span class="cov0" title="0">trigger, err := s.repos.Trigger.FetchTriggerByID(ctx, triggerId)
        if trigger == nil </span><span class="cov0" title="0">{
                return errs.NewNotFoundError("Trigger not found", "TRIGGER_NOT_FOUND", err)
        }</span>
        <span class="cov0" title="0">if err := s.repos.Trigger.DeleteTrigger(ctx, trigger); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *triggerService) GetTrigger(ctx context.Context, triggerId uint64) (*model.Trigger, error) <span class="cov0" title="0">{
        if err := api.IsAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Unauthorized access", logger.Field("error", err))
                return nil, err
        }</span>
        <span class="cov0" title="0">trigger, err := s.repos.Trigger.FetchTriggerByID(ctx, triggerId)
        if trigger == nil </span><span class="cov0" title="0">{
                return nil, errs.NewNotFoundError("Trigger not found", "TRIGGER_NOT_FOUND", err)
        }</span>
        <span class="cov0" title="0">return trigger, nil</span>
}

func (s *triggerService) ListTriggers(ctx context.Context, page, limit int) (*api.List[model.Trigger], error) <span class="cov0" title="0">{
        if err := api.IsAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Unauthorized access", logger.Field("error", err))
                return nil, err
        }</span>
        <span class="cov0" title="0">triggers, err := s.repos.Trigger.FetchTriggers(ctx, page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">total, err := s.repos.Trigger.CountTriggers(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;api.List[model.Trigger]{Items: triggers, Total: total, Page: page, Limit: limit}, nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package service

import (
        "context"
        "github.com/abdelrahman146/digital-wallet/internal/model"
        "github.com/abdelrahman146/digital-wallet/internal/repository"
        "github.com/abdelrahman146/digital-wallet/pkg/api"
        "github.com/abdelrahman146/digital-wallet/pkg/errs"
        "github.com/abdelrahman146/digital-wallet/pkg/logger"
        "github.com/abdelrahman146/digital-wallet/pkg/validator"
)

type UserService interface {
        CreateUser(ctx context.Context, req *CreateUserRequest) (*model.User, error)
        GetUserByID(ctx context.Context, userId string) (*model.User, error)
        SetUserTier(ctx context.Context, userId string, tierId string) (*model.User, error)
        GetUsersByTierID(ctx context.Context, tierId string, page int, limit int) (*api.List[model.User], error)
        GetUsers(ctx context.Context, page int, limit int) (*api.List[model.User], error)
        DeleteUser(ctx context.Context, userId string) error
}

type userService struct {
        repos *repository.Repos
}

func NewUserService(repos *repository.Repos) UserService <span class="cov0" title="0">{
        return &amp;userService{repos: repos}
}</span>

func (s *userService) CreateUser(ctx context.Context, req *CreateUserRequest) (*model.User, error) <span class="cov0" title="0">{
        if err := validator.GetValidator().ValidateStruct(req); err != nil </span><span class="cov0" title="0">{
                fields := validator.GetValidator().GetValidationErrors(err)
                api.GetLogger(ctx).Error("Invalid user request", logger.Field("fields", fields), logger.Field("request", req))
                return nil, errs.NewValidationError("Invalid user request", "", fields)
        }</span>
        <span class="cov0" title="0">user, _ := s.repos.User.FetchUserByID(ctx, req.ID)
        if user != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("User already exists", logger.Field("userId", req.ID))
                return nil, errs.NewConflictError("User already exists", "USER_ALREADY_EXISTS", nil)
        }</span>
        <span class="cov0" title="0">user = &amp;model.User{
                ID:     req.ID,
                TierID: req.TierID,
        }
        if err := s.repos.User.CreateUser(ctx, user); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return user, nil</span>
}

func (s *userService) GetUserByID(ctx context.Context, userId string) (*model.User, error) <span class="cov0" title="0">{
        user, err := s.repos.User.FetchUserByID(ctx, userId)
        if user == nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("User not found", logger.Field("userId", userId), logger.Field("error", err))
                return nil, errs.NewNotFoundError("User not found", "USER_NOT_FOUND", err)
        }</span>
        <span class="cov0" title="0">return user, nil</span>
}

func (s *userService) SetUserTier(ctx context.Context, userId string, tierId string) (*model.User, error) <span class="cov0" title="0">{
        user, err := s.repos.User.FetchUserByID(ctx, userId)
        if user == nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("User not found", logger.Field("userId", userId), logger.Field("error", err))
                return nil, errs.NewNotFoundError("User not found", "USER_NOT_FOUND", err)
        }</span>
        <span class="cov0" title="0">if err := s.repos.User.UpdateUserTier(ctx, userId, tierId); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return user, nil</span>
}

func (s *userService) GetUsersByTierID(ctx context.Context, tierId string, page int, limit int) (*api.List[model.User], error) <span class="cov0" title="0">{
        users, err := s.repos.User.FetchUsersByTierID(ctx, tierId, page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">total, err := s.repos.User.CountUsersByTierID(ctx, tierId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;api.List[model.User]{Items: users, Total: total, Page: page, Limit: limit}, nil</span>
}

func (s *userService) GetUsers(ctx context.Context, page int, limit int) (*api.List[model.User], error) <span class="cov0" title="0">{
        users, err := s.repos.User.FetchUsers(ctx, page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">total, err := s.repos.User.CountTotalUsers(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;api.List[model.User]{Items: users, Total: total, Page: page, Limit: limit}, nil</span>
}

func (s *userService) DeleteUser(ctx context.Context, userId string) error <span class="cov0" title="0">{
        if err := api.IsAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("User not authorized")
                return err
        }</span>
        <span class="cov0" title="0">user, err := s.repos.User.FetchUserByID(ctx, userId)
        if user == nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("User not found", logger.Field("userId", userId), logger.Field("error", err))
                return errs.NewNotFoundError("User not found", "USER_NOT_FOUND", err)
        }</span>
        <span class="cov0" title="0">user.SetActor(api.GetActor(ctx), api.GetActorID(ctx))
        user.SetRemarks("User deleted")
        user.SetOldRecord(*user)
        return s.repos.User.DeleteUser(ctx, user)</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package service

import (
        "context"
        "github.com/abdelrahman146/digital-wallet/internal/model"
        "github.com/abdelrahman146/digital-wallet/internal/repository"
        "github.com/abdelrahman146/digital-wallet/pkg/api"
        "github.com/abdelrahman146/digital-wallet/pkg/errs"
        "github.com/abdelrahman146/digital-wallet/pkg/logger"
        "github.com/abdelrahman146/digital-wallet/pkg/types"
        "github.com/abdelrahman146/digital-wallet/pkg/validator"
        "time"
)

type WalletService interface {
        // CreateWallet creates a new wallet
        CreateWallet(ctx context.Context, req *CreateWalletRequest) (*model.Wallet, error)
        // GetAccountsSum fetches the sum of all accounts for a wallet
        GetAccountsSum(ctx context.Context, walletId string) (uint64, error)
        // GetTransactionsSum fetches the sum of all transactions for a wallet
        GetTransactionsSum(ctx context.Context, walletId string) (uint64, error)
        // UpdateWallet updates a wallet
        UpdateWallet(ctx context.Context, walletId string, req *UpdateWalletRequest) (*model.Wallet, error)
        // GetWalletByID fetches a wallet by ID
        GetWalletByID(ctx context.Context, walletId string) (*model.Wallet, error)
        // GetWallets fetches all wallets
        GetWallets(ctx context.Context, page int, limit int) (*api.List[model.Wallet], error)
        // DeleteWallet deletes a wallet by ID
        DeleteWallet(ctx context.Context, walletId string) error
}

type walletService struct {
        repos *repository.Repos
}

func NewWalletService(repos *repository.Repos) WalletService <span class="cov0" title="0">{
        return &amp;walletService{repos: repos}
}</span>

func (s *walletService) CreateWallet(ctx context.Context, req *CreateWalletRequest) (*model.Wallet, error) <span class="cov0" title="0">{
        if err := api.IsAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("User not authorized")
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := validator.GetValidator().ValidateStruct(req); err != nil </span><span class="cov0" title="0">{
                fields := validator.GetValidator().GetValidationErrors(err)
                api.GetLogger(ctx).Error("Invalid request", logger.Field("fields", fields), logger.Field("request", req))
                return nil, errs.NewValidationError("Invalid request", "", fields)
        }</span>
        <span class="cov0" title="0">wallet := &amp;model.Wallet{
                ID:           req.ID,
                Name:         req.Name,
                Description:  req.Description,
                Currency:     req.Currency,
                LimitPerUser: req.LimitPerUser,
                IsMonetary:   req.IsMonetary,
                LimitGlobal:  req.LimitGlobal,
        }
        wallet.SetActor(api.GetActor(ctx), api.GetActorID(ctx))
        wallet.SetRemarks("Wallet created")
        if req.PointsExpireAfter != nil </span><span class="cov0" title="0">{
                pointsExpireAfter := types.Interval(time.Duration(*req.PointsExpireAfter) * time.Millisecond)
                wallet.PointsExpireAfter = &amp;pointsExpireAfter
        }</span>
        <span class="cov0" title="0">if err := s.repos.Wallet.CreateWallet(ctx, wallet); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return wallet, nil</span>
}

func (s *walletService) UpdateWallet(ctx context.Context, walletId string, req *UpdateWalletRequest) (*model.Wallet, error) <span class="cov0" title="0">{
        if err := api.IsAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("User not authorized")
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := validator.GetValidator().ValidateStruct(req); err != nil </span><span class="cov0" title="0">{
                fields := validator.GetValidator().GetValidationErrors(err)
                api.GetLogger(ctx).Error("Invalid transaction request", logger.Field("fields", fields), logger.Field("request", req))
                return nil, errs.NewValidationError("Invalid transaction request", "", fields)
        }</span>
        <span class="cov0" title="0">wallet, err := s.repos.Wallet.FetchWalletByID(ctx, walletId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">wallet.SetActor(api.GetActor(ctx), api.GetActorID(ctx))
        wallet.SetRemarks("Wallet updated")
        wallet.SetOldRecord(*wallet)
        wallet.Name = req.Name
        wallet.Description = req.Description
        wallet.Currency = req.Currency
        wallet.LimitPerUser = req.LimitPerUser
        wallet.LimitGlobal = req.LimitGlobal
        if req.IsMonetary != nil </span><span class="cov0" title="0">{
                wallet.IsMonetary = *req.IsMonetary
        }</span>
        <span class="cov0" title="0">if req.PointsExpireAfter != nil </span><span class="cov0" title="0">{
                pointsExpireAfter := types.Interval(time.Duration(*req.PointsExpireAfter) * time.Millisecond)
                wallet.PointsExpireAfter = &amp;pointsExpireAfter
        }</span>

        <span class="cov0" title="0">if err := s.repos.Wallet.UpdateWallet(ctx, wallet); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return wallet, nil</span>
}

func (s *walletService) GetWalletByID(ctx context.Context, walletId string) (*model.Wallet, error) <span class="cov0" title="0">{
        wallet, err := s.repos.Wallet.FetchWalletByID(ctx, walletId)
        if wallet == nil </span><span class="cov0" title="0">{
                return nil, errs.NewNotFoundError("wallet not found", "WALLET_NOT_FOUND", err)
        }</span>
        <span class="cov0" title="0">return wallet, nil</span>
}

func (s *walletService) GetWallets(ctx context.Context, page int, limit int) (*api.List[model.Wallet], error) <span class="cov0" title="0">{
        wallets, err := s.repos.Wallet.FetchWallets(ctx, page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">total, err := s.repos.Wallet.CountTotalWallets(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;api.List[model.Wallet]{Items: wallets, Page: page, Limit: limit, Total: total}, nil</span>
}

func (s *walletService) DeleteWallet(ctx context.Context, walletId string) error <span class="cov0" title="0">{
        if err := api.IsAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("User not authorized")
                return err
        }</span>
        <span class="cov0" title="0">wallet, err := s.repos.Wallet.FetchWalletByID(ctx, walletId)
        if wallet == nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("Wallet not found", logger.Field("walletId", walletId), logger.Field("error", err))
                return errs.NewNotFoundError("wallet not found", "WALLET_NOT_FOUND", err)
        }</span>
        <span class="cov0" title="0">wallet.SetActor(api.GetActor(ctx), api.GetActorID(ctx))
        wallet.SetRemarks("Wallet deleted")
        wallet.SetOldRecord(*wallet)
        return s.repos.Wallet.DeleteWallet(ctx, wallet)</span>
}

func (s *walletService) GetAccountsSum(ctx context.Context, walletId string) (uint64, error) <span class="cov0" title="0">{
        if err := api.IsAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("User not authorized")
                return 0, err
        }</span>
        <span class="cov0" title="0">return s.repos.Account.SumWalletAccounts(ctx, walletId)</span>
}

func (s *walletService) GetTransactionsSum(ctx context.Context, walletId string) (uint64, error) <span class="cov0" title="0">{
        if err := api.IsAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                api.GetLogger(ctx).Error("User not authorized")
                return 0, err
        }</span>
        <span class="cov0" title="0">return s.repos.Transaction.SumWalletTransactions(ctx, walletId)</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package main

import (
        backofficev1 "github.com/abdelrahman146/digital-wallet/api/backoffice/v1"
        _ "github.com/abdelrahman146/digital-wallet/docs"
        "github.com/abdelrahman146/digital-wallet/internal/repository"
        "github.com/abdelrahman146/digital-wallet/internal/resource"
        "github.com/abdelrahman146/digital-wallet/internal/service"
        "github.com/abdelrahman146/digital-wallet/pkg/api"
        "github.com/abdelrahman146/digital-wallet/pkg/errs"
        "github.com/abdelrahman146/digital-wallet/pkg/logger"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/middleware/healthcheck"
        "github.com/gofiber/fiber/v2/middleware/helmet"
        "github.com/gofiber/fiber/v2/middleware/idempotency"
        "github.com/gofiber/fiber/v2/middleware/limiter"
        fiberLogger "github.com/gofiber/fiber/v2/middleware/logger"
        "github.com/gofiber/fiber/v2/middleware/monitor"
        "github.com/gofiber/fiber/v2/middleware/recover"
        "github.com/gofiber/fiber/v2/middleware/requestid"
        "github.com/swaggo/fiber-swagger"
        "os"
        "os/signal"
        "syscall"
        "time"
)

// @title Digital Wallet API
// @version 1.0
// @description This is the Digital Wallet API documentation
// @termsOfService http://swagger.io/terms/

// @contact.name Abdel Rahman Hussein
// @contact.url https://github.com/abdelrahman146

// @host http://localhost:3401
// @BasePath /api/v1
func main() <span class="cov0" title="0">{

        // Initialize app
        app := fiber.New(fiber.Config{
                ErrorHandler: func(ctx *fiber.Ctx, err error) error </span><span class="cov0" title="0">{
                        status, resp := api.NewErrorResponse(err)
                        return ctx.Status(status).JSON(resp)
                }</span>,
        })

        // Middleware setup
        <span class="cov0" title="0">app.Use(recover.New())
        app.Use(healthcheck.New())
        app.Use(helmet.New())
        app.Use(idempotency.New())
        app.Use(limiter.New(limiter.Config{
                Max:        10,
                Expiration: 10 * time.Second,
        }))
        app.Use(requestid.New())

        app.Get("/metrics", monitor.New())
        app.Get("/swagger/*", fiberSwagger.WrapHandler)
        app.Use(fiberLogger.New(fiberLogger.Config{
                Format: "${time}: [${ip}:${port}] [${pid}] requestId:${locals:requestid} ${status} - ${method} ${path} ${latency}\n",
        }))

        // Initialize resources
        db := resource.InitDB()
        broker := resource.InitBroker("wallet")

        resources := &amp;resource.Resources{
                DB:     db,
                Broker: broker,
        }

        // Define repositories
        repos := &amp;repository.Repos{
                Audit:        repository.NewAuditRepo(resources),
                Account:      repository.NewAccountRepo(resources),
                Transaction:  repository.NewTransactionRepo(resources),
                Wallet:       repository.NewWalletRepo(resources),
                User:         repository.NewUserRepo(resources),
                Tier:         repository.NewTierRepo(resources),
                ExchangeRate: repository.NewExchangeRateRepo(resources),
                Trigger:      repository.NewTriggerRepo(resources),
                Program:      repository.NewProgramRepo(resources),
        }

        // Define services
        services := &amp;service.Services{
                Audit:        service.NewAuditService(repos),
                Wallet:       service.NewWalletService(repos),
                Transaction:  service.NewTransactionService(repos),
                Account:      service.NewAccountService(repos),
                User:         service.NewUserService(repos),
                Tier:         service.NewTierService(repos),
                ExchangeRate: service.NewExchangeRateService(repos),
                Trigger:      service.NewTriggerService(repos),
                Program:      service.NewProgramService(repos),
        }

        // Define routes
        backofficev1.New(app, services)

        // Undefined route handler
        app.Use(func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                logger.GetLogger().Info("Route not found", logger.Field("path", c.Path()))
                return errs.NewNotFoundError("Route not found", "", nil)
        }</span>)

        // Signal handling for graceful shutdown
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)

        // Start the server in a goroutine
        go func() </span><span class="cov0" title="0">{
                if err := app.Listen(":3401"); err != nil </span><span class="cov0" title="0">{
                        logger.GetLogger().Panic("failed to start server", logger.Field("error", err))
                }</span>
        }()

        // Wait for interrupt signal
        <span class="cov0" title="0">&lt;-quit

        // Gracefully shutdown the server and close the database connection
        logger.GetLogger().Info("Shutting down server...")
        if err := app.Shutdown(); err != nil </span><span class="cov0" title="0">{
                logger.GetLogger().Error("Error shutting down server", logger.Field("error", err))
        }</span>
        <span class="cov0" title="0">resource.CloseDB(db)
        logger.GetLogger().Info("Database connection closed")
        broker.Close()
        logger.GetLogger().Info("Broker connection closed")</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package api

import "github.com/gofiber/fiber/v2"

func AdminAuthenticationMiddleware() fiber.Handler <span class="cov0" title="0">{
        return func(ctx *fiber.Ctx) error </span><span class="cov0" title="0">{
                // get jwt token
                // validate jwt token
                // get user id from jwt token
                ctx.Locals("actorId", "admin_id")
                return ctx.Next()
        }</span>
}

func UserAuthenticationMiddleware() fiber.Handler <span class="cov0" title="0">{
        return func(ctx *fiber.Ctx) error </span><span class="cov0" title="0">{
                // get jwt token
                // validate jwt token
                // get user id from jwt token
                ctx.Locals("actorId", "user_id")
                return ctx.Next()
        }</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package api

import (
        "context"
        "github.com/abdelrahman146/digital-wallet/pkg/errs"
)

func IsAuthorizedUser(ctx context.Context, recordOwner string) error <span class="cov0" title="0">{
        actor := GetActor(ctx)
        actorId := GetActorID(ctx)
        if actor != "" &amp;&amp; actorId != "" &amp;&amp; (actor == AppActorAdmin || actor == AppActorSystem || actorId == recordOwner) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return errs.NewUnauthorizedError("Unauthorized", "", nil)</span>
}

func IsAdmin(ctx context.Context) error <span class="cov0" title="0">{
        actor := GetActor(ctx)
        if actor != "" &amp;&amp; (actor == AppActorAdmin || actor == AppActorSystem) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return errs.NewUnauthorizedError("Unauthorized", "", nil)</span>
}

func IsSystem(ctx context.Context) error <span class="cov0" title="0">{
        actor := GetActor(ctx)
        if actor == AppActorSystem </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return errs.NewUnauthorizedError("Unauthorized", "", nil)</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package api

import (
        "context"
        "github.com/abdelrahman146/digital-wallet/pkg/logger"
        "github.com/gofiber/fiber/v2"
        "go.uber.org/zap/zapcore"
)

func CreateAppContext(actor string) fiber.Handler <span class="cov0" title="0">{
        return func(ctx *fiber.Ctx) error </span><span class="cov0" title="0">{
                requestId := ctx.Locals("requestid").(string)
                actorId := ctx.Locals("actorId").(string)
                l, err := logger.NewZapLogger(zapcore.DebugLevel, logger.Field("requestId", requestId), logger.Field("actor", actor), logger.Field("actorId", actorId))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">ctx.Locals("logger", l)
                ctx.Locals("actor", actor)
                return ctx.Next()</span>
        }
}

func GetLogger(ctx context.Context) logger.Logger <span class="cov0" title="0">{
        return ctx.Value("logger").(logger.Logger)
}</span>

func GetRequestID(ctx context.Context) string <span class="cov0" title="0">{
        return ctx.Value("requestId").(string)
}</span>

func GetActorID(ctx context.Context) string <span class="cov0" title="0">{
        return ctx.Value("actorId").(string)
}</span>

func GetActor(ctx context.Context) string <span class="cov0" title="0">{
        return ctx.Value("actor").(string)
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package api

import (
        "github.com/abdelrahman146/digital-wallet/pkg/errs"
        "github.com/gofiber/fiber/v2"
        "strconv"
)

func GetPageAndLimit(c *fiber.Ctx) (int, int, error) <span class="cov0" title="0">{
        page, limit := 1, 10
        var err error
        if c.Query("page") != "" </span><span class="cov0" title="0">{
                if page, err = strconv.Atoi(c.Query("page")); err != nil </span><span class="cov0" title="0">{
                        return 0, 0, errs.NewBadRequestError("invalid page", "INVALID_PAGE_PARAM", err)
                }</span>
        }
        <span class="cov0" title="0">if c.Query("limit") != "" </span><span class="cov0" title="0">{
                if limit, err = strconv.Atoi(c.Query("limit")); err != nil </span><span class="cov0" title="0">{
                        return 0, 0, errs.NewBadRequestError("invalid limit", "INVALID_LIMIT_PARAM", err)
                }</span>
        }
        <span class="cov0" title="0">return page, limit, nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package api

import "github.com/abdelrahman146/digital-wallet/pkg/errs"

func NewErrorResponse(err error) (httpCode int, resp ErrorResponse) <span class="cov0" title="0">{
        customErr := errs.HandleError(err)
        httpCode = customErr.HttpCode
        body := ErrorResponseBody{
                Message:  customErr.Message,
                HttpCode: customErr.HttpCode,
                Code:     customErr.Code,
        }
        if customErr.Original != nil </span><span class="cov0" title="0">{
                body.Reason = customErr.Original.Error()
        }</span>
        <span class="cov0" title="0">if customErr.Fields != nil </span><span class="cov0" title="0">{
                body.Fields = customErr.Fields
        }</span>
        <span class="cov0" title="0">resp = ErrorResponse{
                Success: false,
                Error:   body,
        }
        return httpCode, resp</span>
}

func NewSuccessResponse(result interface{}) SuccessResponse <span class="cov0" title="0">{
        return SuccessResponse{
                Success: true,
                Result:  result,
        }
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package config

import (
        "fmt"
        "os"
)

type Config struct {
        DbHost       string
        DbPort       string
        DbUser       string
        DbPassword   string
        DbName       string
        DbSSLMode    string
        DebugLevel   string
        KafkaBrokers string
}

var config *Config

func GetConfig() *Config <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                config = loadConfig()
        }</span>
        <span class="cov0" title="0">return config</span>
}

func loadConfig() *Config <span class="cov0" title="0">{
        return &amp;Config{
                DbHost:       GetEnv("DB_HOST", "localhost"),
                DbPort:       GetEnv("DB_PORT", "5432"),
                DbUser:       GetEnv("DB_USER", "postgres"),
                DbPassword:   GetEnv("DB_PASSWORD", "password"),
                DbName:       GetEnv("DB_NAME", "digital_wallet"),
                DbSSLMode:    GetEnv("DB_SSLMODE", "disable"),
                DebugLevel:   GetEnv("DEBUG_LEVEL", "info"),
                KafkaBrokers: GetEnv("KAFKA_BROKERS", "localhost:9092"),
        }
}</span>

func GetEnv(key, fallback string) string <span class="cov0" title="0">{
        if value, exists := os.LookupEnv(key); exists </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return fallback</span>
}

func (c *Config) GetDbConnectionString() string <span class="cov0" title="0">{
        return fmt.Sprintf("host=%s port=%s user=%s dbname=%s password=%s sslmode=%s",
                c.DbHost, c.DbPort, c.DbUser, c.DbName, c.DbPassword, c.DbSSLMode)
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package errs

import "github.com/abdelrahman146/digital-wallet/pkg/utils"

func NewValidationError(text string, code string, fields map[string]string) CustomError <span class="cov0" title="0">{
        return CustomError{
                Message:  utils.Coalesce(text, "Could not understand the request due to invalid syntax."),
                Code:     utils.Coalesce(code, "VALIDATION_ERROR"),
                HttpCode: 400,
                Fields:   fields,
        }
}</span>

func NewNotFoundError(text string, code string, err error) CustomError <span class="cov0" title="0">{
        return CustomError{
                Message:  utils.Coalesce(text, "Resource could not be found"),
                Code:     utils.Coalesce(code, "NOT_FOUND"),
                HttpCode: 404,
                Original: err,
        }
}</span>

func NewConflictError(text string, code string, err error) CustomError <span class="cov0" title="0">{
        return CustomError{
                Message:  utils.Coalesce(text, "Uncompleted request due to a conflict with the current state of the target resources."),
                Code:     utils.Coalesce(code, "CONFLICT"),
                HttpCode: 409,
                Original: err,
        }
}</span>

func NewUnauthorizedError(text string, code string, err error) CustomError <span class="cov0" title="0">{
        return CustomError{
                Message:  utils.Coalesce(text, "Authorization required for the target resources."),
                Code:     utils.Coalesce(code, "UNAUTHORIZED"),
                HttpCode: 401,
                Original: err,
        }
}</span>

func NewForbiddenError(text string, code string, err error) CustomError <span class="cov0" title="0">{
        return CustomError{
                Message:  utils.Coalesce(text, "Request understood, but refused"),
                Code:     utils.Coalesce(code, "FORBIDDEN"),
                HttpCode: 403,
                Original: err,
        }
}</span>

func NewBadRequestError(text string, code string, err error) CustomError <span class="cov0" title="0">{
        return CustomError{
                Message:  utils.Coalesce(text, "Could not understand the request due to invalid syntax."),
                Code:     utils.Coalesce(code, "BAD_REQUEST"),
                HttpCode: 400,
                Original: err,
        }
}</span>

func NewPaymentRequiredError(text string, code string, err error) CustomError <span class="cov0" title="0">{
        return CustomError{
                Message:  utils.Coalesce(text, "Payment required for the target resources."),
                Code:     utils.Coalesce(code, "PAYMENT_REQUIRED"),
                HttpCode: 402,
                Original: err,
        }
}</span>
func NewMethodNotAllowedError(text string, code string, err error) CustomError <span class="cov0" title="0">{
        return CustomError{
                Message:  utils.Coalesce(text, "Request method not supported for the target resources."),
                Code:     utils.Coalesce(code, "METHOD_NOT_ALLOWED"),
                HttpCode: 405,
                Original: err,
        }
}</span>

func NewNotAcceptableError(text string, code string, err error) CustomError <span class="cov0" title="0">{
        return CustomError{
                Message:  utils.Coalesce(text, "Request not acceptable for the target resources."),
                Code:     utils.Coalesce(code, "NOT_ACCEPTABLE"),
                HttpCode: 406,
                Original: err,
        }
}</span>
func NewTimeoutError(text string, code string, err error) CustomError <span class="cov0" title="0">{
        return CustomError{
                Message:  utils.Coalesce(text, "Request timeout"),
                Code:     utils.Coalesce(code, "TIMEOUT"),
                HttpCode: 408,
                Original: err,
        }
}</span>

func NewPayloadTooLargeError(text string, code string, err error) CustomError <span class="cov0" title="0">{
        return CustomError{
                Message:  utils.Coalesce(text, "Request payload too large"),
                Code:     utils.Coalesce(code, "PAYLOAD_TOO_LARGE"),
                HttpCode: 413,
                Original: err,
        }
}</span>

func NewUnsupportedMediaTypeError(text string, code string, err error) CustomError <span class="cov0" title="0">{
        return CustomError{
                Message:  utils.Coalesce(text, "Unsupported media type"),
                Code:     utils.Coalesce(code, "UNSUPPORTED_MEDIA_TYPE"),
                HttpCode: 415,
                Original: err,
        }
}</span>

func NewExpectationFailedError(text string, code string, err error) CustomError <span class="cov0" title="0">{
        return CustomError{
                Message:  utils.Coalesce(text, "Expectation failed"),
                Code:     utils.Coalesce(code, "EXPECTATION_FAILED"),
                HttpCode: 417,
                Original: err,
        }
}</span>

func NewTooManyRequestsError(text string, code string, err error) CustomError <span class="cov0" title="0">{
        return CustomError{
                Message:  utils.Coalesce(text, "Too many requests"),
                Code:     utils.Coalesce(code, "TOO_MANY_REQUESTS"),
                HttpCode: 429,
                Original: err,
        }
}</span>

func NewUnprocessableEntityError(text string, code string, err error) CustomError <span class="cov0" title="0">{
        return CustomError{
                Message:  utils.Coalesce(text, "Well formed request, but was unable to be followed due to semantic errors."),
                Code:     utils.Coalesce(code, "UNPROCESSABLE_ENTITY"),
                HttpCode: 422,
                Original: err,
        }
}</span>

func NewInternalError(text string, code string, e error) CustomError <span class="cov0" title="0">{
        return CustomError{
                Message:  utils.Coalesce(text, "Encountered an unexpected condition that prevented it from fulfilling the request."),
                Code:     utils.Coalesce(code, "INTERNAL_ERROR"),
                HttpCode: 500,
                Original: e,
        }
}</span>
func NewNotImplementedError(text string, code string, e error) CustomError <span class="cov0" title="0">{
        return CustomError{
                Message:  utils.Coalesce(text, "The server does not support the functionality required to fulfill the request."),
                Code:     utils.Coalesce(code, "NOT_IMPLEMENTED"),
                HttpCode: 501,
                Original: e,
        }
}</span>

func NewServiceUnavailableError(text string, code string, e error) CustomError <span class="cov0" title="0">{
        return CustomError{
                Message:  utils.Coalesce(text, "The server is currently unavailable."),
                Code:     utils.Coalesce(code, "SERVICE_UNAVAILABLE"),
                HttpCode: 503,
                Original: e,
        }
}</span>

func NewUnknownError(e error) CustomError <span class="cov0" title="0">{
        return CustomError{
                Message:  "Unhandled Error",
                Code:     "UNKNOWN_ERROR",
                HttpCode: 520,
                Original: e,
        }
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package errs

type CustomError struct {
        Message  string
        Code     string            `json:"code"`
        HttpCode int               `json:"httpCode"`
        Original error             `json:"error,omitempty"`
        Fields   map[string]string `json:"fields,omitempty"`
}

func (e CustomError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package errs

import (
        "errors"
        "gorm.io/gorm"
)

func HandleError(err error) CustomError <span class="cov0" title="0">{
        var customError CustomError
        switch </span>{
        case errors.As(err, &amp;customError):<span class="cov0" title="0">
                return err.(CustomError)</span>
        case errors.Is(err, gorm.ErrRecordNotFound):<span class="cov0" title="0">
                return NewNotFoundError(err.Error(), "RECORD_NOT_FOUND", err)</span>
        case errors.Is(err, gorm.ErrCheckConstraintViolated):<span class="cov0" title="0">
                return NewConflictError(err.Error(), "CHECK_CONSTRAINT_VIOLATED", err)</span>
        case errors.Is(err, gorm.ErrInvalidTransaction):<span class="cov0" title="0">
                return NewExpectationFailedError(err.Error(), "INVALID_TRANSACTION", err)</span>
        case errors.Is(err, gorm.ErrUnsupportedRelation):<span class="cov0" title="0">
                return NewExpectationFailedError(err.Error(), "UNSUPPORTED_RELATION", err)</span>
        case errors.Is(err, gorm.ErrPrimaryKeyRequired):<span class="cov0" title="0">
                return NewBadRequestError(err.Error(), "PRIMARY_KEY_REQUIRED", err)</span>
        case errors.Is(err, gorm.ErrModelValueRequired):<span class="cov0" title="0">
                return NewExpectationFailedError(err.Error(), "MODEL_VALUE_REQUIRED", err)</span>
        case errors.Is(err, gorm.ErrInvalidData):<span class="cov0" title="0">
                return NewBadRequestError(err.Error(), "INVALID_DATA", err)</span>
        case errors.Is(err, gorm.ErrRegistered):<span class="cov0" title="0">
                return NewNotAcceptableError(err.Error(), "REGISTERED", err)</span>
        case errors.Is(err, gorm.ErrInvalidField):<span class="cov0" title="0">
                return NewBadRequestError(err.Error(), "INVALID_FIELD", err)</span>
        case errors.Is(err, gorm.ErrInvalidValue):<span class="cov0" title="0">
                return NewBadRequestError(err.Error(), "INVALID_VALUE", err)</span>
        case errors.Is(err, gorm.ErrInvalidValueOfLength):<span class="cov0" title="0">
                return NewBadRequestError(err.Error(), "INVALID_VALUE_OF_LENGTH", err)</span>
        case errors.Is(err, gorm.ErrPreloadNotAllowed):<span class="cov0" title="0">
                return NewNotAcceptableError(err.Error(), "PRELOAD_NOT_ALLOWED", err)</span>
        case errors.Is(err, gorm.ErrDuplicatedKey):<span class="cov0" title="0">
                return NewConflictError(err.Error(), "DUPLICATED_KEY", err)</span>
        case errors.Is(err, gorm.ErrForeignKeyViolated):<span class="cov0" title="0">
                return NewBadRequestError(err.Error(), "FOREIGN_KEY_VIOLATED", err)</span>
        // default
        default:<span class="cov0" title="0">
                return NewUnknownError(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package logger

import (
        "go.uber.org/zap/zapcore"
        "sync"
)

type F struct {
        Key   string
        Value interface{}
}

type Logger interface {
        Debug(msg string, fields ...F)
        Info(msg string, fields ...F)
        Warn(msg string, fields ...F)
        Error(msg string, fields ...F)
        Panic(msg string, fields ...F)
}

var (
        logger Logger
        once   sync.Once
)

func initLogger(l Logger) <span class="cov0" title="0">{
        once.Do(func() </span><span class="cov0" title="0">{
                logger = l
        }</span>)
}

func GetLogger() Logger <span class="cov0" title="0">{
        if logger == nil </span><span class="cov0" title="0">{
                zap, err := NewZapLogger(zapcore.DebugLevel)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov0" title="0">initLogger(zap)</span>
        }
        <span class="cov0" title="0">return logger</span>
}

func Field(key string, value interface{}) F <span class="cov0" title="0">{
        return F{Key: key, Value: value}
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package logger

import (
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

type zapLogger struct {
        logger *zap.Logger
        level  zapcore.Level
}

func NewZapLogger(level zapcore.Level, fields ...F) (Logger, error) <span class="cov0" title="0">{
        zl := &amp;zapLogger{level: level}
        logger, err := zl.Setup(fields...)
        zl.logger = logger
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return zl, nil</span>
}

func (zl *zapLogger) Setup(fields ...F) (*zap.Logger, error) <span class="cov0" title="0">{
        config := zap.Config{
                Encoding:         "console",
                Level:            zap.NewAtomicLevelAt(zl.level),
                OutputPaths:      []string{"stdout"},
                ErrorOutputPaths: []string{"stderr"},
                EncoderConfig: zapcore.EncoderConfig{
                        TimeKey:    "time",
                        LevelKey:   "level",
                        NameKey:    "logger",
                        CallerKey:  "caller",
                        MessageKey: "msg",
                        //StacktraceKey:  "stacktrace",
                        LineEnding:     zapcore.DefaultLineEnding,
                        EncodeLevel:    zapcore.CapitalColorLevelEncoder,
                        EncodeTime:     zapcore.ISO8601TimeEncoder,
                        EncodeDuration: zapcore.StringDurationEncoder,
                        EncodeCaller:   zapcore.ShortCallerEncoder,
                },
        }
        logger, err := config.Build()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">logger = logger.WithOptions(zap.AddCaller(), zap.AddCallerSkip(1))
        for _, field := range fields </span><span class="cov0" title="0">{
                logger = logger.With(zap.Any(field.Key, field.Value))
        }</span>
        <span class="cov0" title="0">return logger, nil</span>
}

func (zl *zapLogger) Debug(msg string, fields ...F) <span class="cov0" title="0">{
        var zapFields []zap.Field
        for i := 0; i &lt; len(fields); i++ </span><span class="cov0" title="0">{
                zapFields = append(zapFields, zap.Any(fields[i].Key, fields[i].Value))
        }</span>
        <span class="cov0" title="0">zl.logger.Debug(msg, zapFields...)</span>
}

func (zl *zapLogger) Info(msg string, fields ...F) <span class="cov0" title="0">{
        var zapFields []zap.Field
        for _, field := range fields </span><span class="cov0" title="0">{
                zapFields = append(zapFields, zap.Any(field.Key, field.Value))
        }</span>
        <span class="cov0" title="0">zl.logger.Info(msg, zapFields...)</span>
}

func (zl *zapLogger) Warn(msg string, fields ...F) <span class="cov0" title="0">{
        var zapFields []zap.Field
        for _, field := range fields </span><span class="cov0" title="0">{
                zapFields = append(zapFields, zap.Any(field.Key, field.Value))
        }</span>
        <span class="cov0" title="0">zl.logger.Warn(msg, zapFields...)</span>
}

func (zl *zapLogger) Error(msg string, fields ...F) <span class="cov0" title="0">{
        var zapFields []zap.Field
        for _, field := range fields </span><span class="cov0" title="0">{
                zapFields = append(zapFields, zap.Any(field.Key, field.Value))
        }</span>
        <span class="cov0" title="0">zl.logger.Error(msg, zapFields...)</span>
}

func (zl *zapLogger) Panic(msg string, fields ...F) <span class="cov0" title="0">{
        var zapFields []zap.Field
        for _, field := range fields </span><span class="cov0" title="0">{
                zapFields = append(zapFields, zap.Any(field.Key, field.Value))
        }</span>
        <span class="cov0" title="0">zl.logger.Panic(msg, zapFields...)</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package rule_engine

import (
        "encoding/json"
        "fmt"
)

func Evaluate(rule Rule, data []byte) (bool, error) <span class="cov8" title="1">{
        var jsonObject map[string]interface{}
        err := json.Unmarshal(data, &amp;jsonObject)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("invalid JSON data: %v", err)
        }</span>
        <span class="cov8" title="1">return evaluateRule(rule, jsonObject)</span>
}

// evaluateRule recursively evaluates rules, including logical combinations (AND, OR, NOT).
func evaluateRule(rule Rule, jsonObject map[string]interface{}) (bool, error) <span class="cov8" title="1">{
        if rule.Logic != "" </span><span class="cov8" title="1">{
                return evaluateLogic(rule, jsonObject)
        }</span>

        <span class="cov8" title="1">fieldValue, exists := getField(jsonObject, rule.Field)
        if !exists </span><span class="cov0" title="0">{
                return false, fmt.Errorf("field %s not found", rule.Field)
        }</span>

        // Handle array fields - Check if it's an array and operator is related to array handling (e.g., "any", "all")
        <span class="cov8" title="1">if array, ok := fieldValue.([]interface{}); ok &amp;&amp; (rule.Operator == "any" || rule.Operator == "all") </span><span class="cov8" title="1">{
                return evaluateArray(rule, array, rule.Operator == "all")
        }</span>

        // Evaluate the operator
        <span class="cov8" title="1">return evaluateOperator(rule.Operator, fieldValue, rule.Val)</span>
}

// evaluateArray applies a rule to each element in an array (supports "all" or "any").
func evaluateArray(rule Rule, jsonArray []interface{}, matchAll bool) (bool, error) <span class="cov8" title="1">{
        for _, element := range jsonArray </span><span class="cov8" title="1">{
                jsonObject, ok := element.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("array element is not a JSON object")
                }</span>

                // Iterate through all sub-rules and evaluate them for each array element
                <span class="cov8" title="1">for _, subRule := range rule.Rules </span><span class="cov8" title="1">{
                        result, err := evaluateRule(subRule, jsonObject)
                        if err != nil </span><span class="cov0" title="0">{
                                return false, err
                        }</span>

                        // For "all" case, return false if any rule fails for any element
                        <span class="cov8" title="1">if matchAll &amp;&amp; !result </span><span class="cov8" title="1">{
                                return false, nil
                        }</span>

                        // For "any" case, return true if any rule passes for at least one element
                        <span class="cov8" title="1">if !matchAll &amp;&amp; result </span><span class="cov8" title="1">{
                                return true, nil
                        }</span>
                }
        }

        // If it's an "all" rule, return true because all elements passed all rules
        // If it's an "any" rule, return false because no element satisfied any rule
        <span class="cov8" title="1">return matchAll, nil</span>
}

// evaluateLogic handles AND, OR, and NOT operations between rules.
func evaluateLogic(rule Rule, jsonObject map[string]interface{}) (bool, error) <span class="cov8" title="1">{
        switch rule.Logic </span>{
        case "AND":<span class="cov8" title="1">
                for _, subRule := range rule.Rules </span><span class="cov8" title="1">{
                        result, err := evaluateRule(subRule, jsonObject)
                        if err != nil || !result </span><span class="cov8" title="1">{
                                return false, err
                        }</span>
                }
                <span class="cov8" title="1">return true, nil</span>
        case "OR":<span class="cov8" title="1">
                for _, subRule := range rule.Rules </span><span class="cov8" title="1">{
                        result, err := evaluateRule(subRule, jsonObject)
                        if result &amp;&amp; err == nil </span><span class="cov8" title="1">{
                                return true, nil
                        }</span>
                }
                <span class="cov8" title="1">return false, nil</span>
        case "NOT":<span class="cov8" title="1">
                if len(rule.Rules) != 1 </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("NOT logic must have exactly one sub-rule")
                }</span>
                <span class="cov8" title="1">result, err := evaluateRule(rule.Rules[0], jsonObject)
                return !result, err</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("unsupported logic operator: %s", rule.Logic)</span>
        }
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package rule_engine

import (
        "fmt"
        "github.com/abdelrahman146/digital-wallet/pkg/utils"
        "reflect"
        "regexp"
        "strings"
)

// evaluateOperator handles all comparisons: numeric, string, and date, based on value types.
func evaluateOperator(operator string, fieldValue, ruleValue interface{}) (bool, error) <span class="cov8" title="1">{
        switch fieldVal := fieldValue.(type) </span>{
        case string:<span class="cov8" title="1">
                if utils.IsDate(fieldValue) || utils.IsDate(ruleValue) </span><span class="cov8" title="1">{
                        return evaluateDateOperator(operator, fieldVal, ruleValue)
                }</span>
                <span class="cov8" title="1">return evaluateString(operator, fieldVal, ruleValue.(string))</span>
        case float64:<span class="cov8" title="1">
                return evaluateNumeric(operator, fieldVal, toFloat64(ruleValue))</span>
        case int, int64, int32:<span class="cov0" title="0">
                return evaluateNumeric(operator, float64(reflect.ValueOf(fieldValue).Int()), toFloat64(ruleValue))</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("unsupported value type for comparison: %v", fieldValue)</span>
        }
}

// evaluateDateOperator compares date values using operators like "before", "after", "on".
func evaluateDateOperator(operator string, fieldValue, ruleValue interface{}) (bool, error) <span class="cov8" title="1">{
        fieldDate, err := utils.ParseDate(fieldValue)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("field value is not a valid date: %v", err)
        }</span>

        <span class="cov8" title="1">ruleDate, err := utils.ParseDate(ruleValue)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("rule value is not a valid date: %v", err)
        }</span>

        <span class="cov8" title="1">switch operator </span>{
        case "==":<span class="cov0" title="0">
                return fieldDate.Equal(ruleDate), nil</span>
        case "!=":<span class="cov0" title="0">
                return !fieldDate.Equal(ruleDate), nil</span>
        case "&gt;":<span class="cov0" title="0">
                return fieldDate.After(ruleDate), nil</span>
        case "&lt;":<span class="cov8" title="1">
                return fieldDate.Before(ruleDate), nil</span>
        case "&gt;=":<span class="cov0" title="0">
                return fieldDate.After(ruleDate) || fieldDate.Equal(ruleDate), nil</span>
        case "&lt;=":<span class="cov8" title="1">
                return fieldDate.Before(ruleDate) || fieldDate.Equal(ruleDate), nil</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("unsupported date operator: %s", operator)</span>
        }
}

// evaluateString handles string comparisons for "==", "!=", "&gt;", "&lt;", "&gt;=", "&lt;="
func evaluateString(operator string, fieldValue string, ruleValue string) (bool, error) <span class="cov8" title="1">{
        switch operator </span>{
        case "==":<span class="cov8" title="1">
                return fieldValue == ruleValue, nil</span>
        case "!=":<span class="cov0" title="0">
                return fieldValue != ruleValue, nil</span>
        case "contains":<span class="cov8" title="1">
                return strings.Contains(fieldValue, ruleValue), nil</span>
        case "in":<span class="cov8" title="1">
                values := strings.Split(ruleValue, ",")
                for _, value := range values </span><span class="cov8" title="1">{
                        if value == fieldValue </span><span class="cov8" title="1">{
                                return true, nil
                        }</span>
                }
                <span class="cov8" title="1">return false, nil</span>
        case "notin":<span class="cov8" title="1">
                values := strings.Split(ruleValue, ",")
                for _, value := range values </span><span class="cov8" title="1">{
                        if value == fieldValue </span><span class="cov8" title="1">{
                                return false, nil
                        }</span>
                }
                <span class="cov8" title="1">return true, nil</span>
        case "matches":<span class="cov8" title="1">
                return regexp.MatchString(ruleValue, fieldValue)</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("unsupported string operator: %s", operator)</span>
        }
}

// evaluateNumeric handles numeric comparisons for "==", "!=", "&gt;", "&lt;", "&gt;=", "&lt;="
func evaluateNumeric(operator string, fieldValue, ruleValue float64) (bool, error) <span class="cov8" title="1">{
        switch operator </span>{
        case "==":<span class="cov0" title="0">
                return fieldValue == ruleValue, nil</span>
        case "!=":<span class="cov0" title="0">
                return fieldValue != ruleValue, nil</span>
        case "&gt;":<span class="cov8" title="1">
                return fieldValue &gt; ruleValue, nil</span>
        case "&lt;":<span class="cov0" title="0">
                return fieldValue &lt; ruleValue, nil</span>
        case "&gt;=":<span class="cov0" title="0">
                return fieldValue &gt;= ruleValue, nil</span>
        case "&lt;=":<span class="cov0" title="0">
                return fieldValue &lt;= ruleValue, nil</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("unsupported numeric operator: %s", operator)</span>
        }
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package rule_engine

import (
        "database/sql/driver"
        "encoding/json"
        "errors"
)

// Rule represents a validation rule. It can include nested rules for AND/OR/NOT logic.
type Rule struct {
        Field    string      `json:"field,omitempty"`    // Field name to apply the rule to (can use dot notation for nested fields like "address.city")
        Operator string      `json:"operator,omitempty"` // Operator for the rule (e.g., "==", "&gt;", "before", "after", etc.)
        Val      interface{} `json:"value,omitempty"`    // Val to compare the field with
        Logic    string      `json:"logic,omitempty"`    // Logical operator for combining rules ("AND", "OR", "NOT")
        Rules    []Rule      `json:"rules,omitempty"`    // Nested rules (used with logic operators)
}

// Value Marshal
func (a Rule) Value() (driver.Value, error) <span class="cov0" title="0">{
        return json.Marshal(a)
}</span>

// Scan Unmarshal
func (a *Rule) Scan(value interface{}) error <span class="cov0" title="0">{
        b, ok := value.([]byte)
        if !ok </span><span class="cov0" title="0">{
                return errors.New("type assertion to []byte failed")
        }</span>
        <span class="cov0" title="0">return json.Unmarshal(b, &amp;a)</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package rule_engine

import (
        "strings"
)

// getField extracts the value from a nested field in the JSON-like map using dot notation.
func getField(jsonObject map[string]interface{}, field string) (interface{}, bool) <span class="cov8" title="1">{
        parts := strings.Split(field, ".")
        var current interface{} = jsonObject
        for _, part := range parts </span><span class="cov8" title="1">{
                if objMap, ok := current.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        current = objMap[part]
                }</span> else<span class="cov0" title="0"> {
                        return nil, false
                }</span>
        }
        <span class="cov8" title="1">return current, true</span>
}

func toFloat64(value interface{}) float64 <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case float64:<span class="cov0" title="0">
                return v</span>
        case int:<span class="cov8" title="1">
                return float64(v)</span>
        case int64:<span class="cov0" title="0">
                return float64(v)</span>
        case float32:<span class="cov0" title="0">
                return float64(v)</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package types

import (
        "database/sql/driver"
        "errors"
        "strings"
        "time"
)

type Interval time.Duration

func (i Interval) Duration() time.Duration <span class="cov0" title="0">{
        return time.Duration(i)
}</span>

func (i Interval) Value() (driver.Value, error) <span class="cov0" title="0">{
        return time.Duration(i).String(), nil
}</span>

func (i *Interval) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">str, ok := value.(string)
        if !ok </span><span class="cov0" title="0">{
                return errors.New("type assertion to string failed")
        }</span>
        // Convert format of hh:mm:ss into format parseable by time.ParseDuration()
        <span class="cov0" title="0">str = strings.Replace(str, ":", "h", 1)
        str = strings.Replace(str, ":", "m", 1)
        str += "s"
        dur, err := time.ParseDuration(str)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*i = Interval(dur)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package types

import (
        "database/sql/driver"
        "encoding/json"
        "errors"
)

// JSONB Interface for JSONB Field
type JSONB map[string]interface{}

// Value Marshal
func (a JSONB) Value() (driver.Value, error) <span class="cov0" title="0">{
        return json.Marshal(a)
}</span>

// Scan Unmarshal
func (a *JSONB) Scan(value interface{}) error <span class="cov0" title="0">{
        b, ok := value.([]byte)
        if !ok </span><span class="cov0" title="0">{
                return errors.New("type assertion to []byte failed")
        }</span>
        <span class="cov0" title="0">return json.Unmarshal(b, &amp;a)</span>
}

func StructToJSONB(value interface{}, j *JSONB) error <span class="cov0" title="0">{
        bytes, err := json.Marshal(value)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = json.Unmarshal(bytes, &amp;j)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package utils

import (
        "errors"
        "time"
)

func GetDateAfter(interval time.Duration) time.Time <span class="cov0" title="0">{
        return time.Now().Add(interval)
}</span>

// ParseDate converts a date string into a time.Time object. Supports multiple date formats.
func ParseDate(value interface{}) (time.Time, error) <span class="cov8" title="1">{
        strValue, ok := value.(string)
        if !ok </span><span class="cov0" title="0">{
                return time.Time{}, errors.New("invalid date format")
        }</span>

        <span class="cov8" title="1">layouts := []string{
                time.RFC3339,       // "2006-01-02T15:04:05Z07:00"
                "2006-01-02",       // "2006-01-02"
                "2006-01-02 15:04", // "2006-01-02 15:04"
                "02-01-2006",       // "02-01-2006" (European format)
        }

        for _, layout := range layouts </span><span class="cov8" title="1">{
                parsed, err := time.Parse(layout, strValue)
                if err == nil </span><span class="cov8" title="1">{
                        return parsed, nil
                }</span>
        }
        <span class="cov8" title="1">return time.Time{}, errors.New("could not parse date")</span>
}

// IsDate checks if a value is a date string.
func IsDate(value interface{}) bool <span class="cov8" title="1">{
        _, err := ParseDate(value)
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package utils

import (
        "golang.org/x/exp/constraints"
)

type Nullable interface {
        constraints.Ordered | ~*any
}

func Coalesce[T Nullable](options ...T) T <span class="cov0" title="0">{
        var zero T
        for _, option := range options </span><span class="cov0" title="0">{
                if option != zero </span><span class="cov0" title="0">{
                        return option
                }</span>
        }
        <span class="cov0" title="0">return zero</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package validator

import (
        "errors"
        "github.com/abdelrahman146/digital-wallet/pkg/logger"
        "github.com/go-playground/locales/en"
        ut "github.com/go-playground/universal-translator"
        "github.com/go-playground/validator/v10"
        en_translations "github.com/go-playground/validator/v10/translations/en"
        "math"
        "regexp"
)

type validatorStruct struct {
        uni      *ut.UniversalTranslator
        validate *validator.Validate
        trans    ut.Translator
}

func NewValidator() Validator <span class="cov0" title="0">{
        v := &amp;validatorStruct{}
        if err := v.init(); err != nil </span><span class="cov0" title="0">{
                logger.GetLogger().Panic("failed to initialize validator", logger.Field("error", err))
        }</span>
        <span class="cov0" title="0">return v</span>
}

func (v *validatorStruct) init() error <span class="cov0" title="0">{
        en := en.New()
        v.uni = ut.New(en, en)
        v.trans, _ = v.uni.GetTranslator("en")
        v.validate = validator.New()
        if err := v.validate.RegisterValidation("decimal2", v.Decimal2); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := v.validate.RegisterValidation("slug", v.Slug); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := v.validate.RegisterValidation("alpha", v.Alpha); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := en_translations.RegisterDefaultTranslations(v.validate, v.trans); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">v.registerDecimal2Translation()
        v.RegisterSlugTranslation()
        return v.RegisterAlphaTranslation()</span>
}

func (v *validatorStruct) ValidateStruct(s interface{}) error <span class="cov0" title="0">{
        return v.validate.Struct(s)
}</span>

func (v *validatorStruct) GetValidationErrors(err error) map[string]string <span class="cov0" title="0">{
        var errs validator.ValidationErrors
        if ok := errors.As(err, &amp;errs); !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">validations := make(map[string]string)
        for _, e := range errs </span><span class="cov0" title="0">{
                validations[e.Field()] = e.Translate(v.trans)
        }</span>
        <span class="cov0" title="0">return validations</span>
}

func (v *validatorStruct) Decimal2(fl validator.FieldLevel) bool <span class="cov0" title="0">{
        amount, ok := fl.Field().Interface().(float64)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return amount == math.Round(amount*100)/100</span>
}

func (v *validatorStruct) registerDecimal2Translation() error <span class="cov0" title="0">{
        return v.validate.RegisterTranslation("decimal2", v.trans, func(ut ut.Translator) error </span><span class="cov0" title="0">{
                return ut.Add("decimal2", "{0} must have two digits only", true)
        }</span>, func(ut ut.Translator, fe validator.FieldError) string <span class="cov0" title="0">{
                t, _ := ut.T("decimal2", fe.Field())
                return t
        }</span>)
}

func (v *validatorStruct) Slug(fl validator.FieldLevel) bool <span class="cov0" title="0">{
        value, ok := fl.Field().Interface().(string)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">matched, _ := regexp.MatchString("^[a-z]+(?:[-_][a-z]+)*$", value)
        return matched</span>
}

func (v *validatorStruct) RegisterSlugTranslation() error <span class="cov0" title="0">{
        return v.validate.RegisterTranslation("slug", v.trans, func(ut ut.Translator) error </span><span class="cov0" title="0">{
                return ut.Add("slug", "{0} must be a valid letters only slug", true)
        }</span>, func(ut ut.Translator, fe validator.FieldError) string <span class="cov0" title="0">{
                t, _ := ut.T("slug", fe.Field())
                return t
        }</span>)
}

func (v *validatorStruct) Alpha(fl validator.FieldLevel) bool <span class="cov0" title="0">{
        value, ok := fl.Field().Interface().(string)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">matched, _ := regexp.MatchString("^[a-zA-Z]+$", value)
        return matched</span>
}

func (v *validatorStruct) RegisterAlphaTranslation() error <span class="cov0" title="0">{
        return v.validate.RegisterTranslation("alpha", v.trans, func(ut ut.Translator) error </span><span class="cov0" title="0">{
                return ut.Add("alpha", "{0} must have letters only", true)
        }</span>, func(ut ut.Translator, fe validator.FieldError) string <span class="cov0" title="0">{
                t, _ := ut.T("alpha", fe.Field())
                return t
        }</span>)
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package validator

type Validator interface {
        ValidateStruct(s interface{}) error
        GetValidationErrors(err error) map[string]string
}

var v Validator

func GetValidator() Validator <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                v = NewValidator()
        }</span>
        <span class="cov0" title="0">return v</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
