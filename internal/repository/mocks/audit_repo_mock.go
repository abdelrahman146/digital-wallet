// Code generated by MockGen. DO NOT EDIT.
// Source: internal/repository/audit_repo.go
//
// Generated by this command:
//
//	mockgen -source=internal/repository/audit_repo.go -destination=internal/repository/mocks/audit_repo_mock.go -package=repository_mock
//

// Package repository_mock is a generated GoMock package.
package repository_mock

import (
	context "context"
	reflect "reflect"

	model "github.com/abdelrahman146/digital-wallet/internal/model"
	gomock "go.uber.org/mock/gomock"
)

// MockAuditRepo is a mock of AuditRepo interface.
type MockAuditRepo struct {
	ctrl     *gomock.Controller
	recorder *MockAuditRepoMockRecorder
}

// MockAuditRepoMockRecorder is the mock recorder for MockAuditRepo.
type MockAuditRepoMockRecorder struct {
	mock *MockAuditRepo
}

// NewMockAuditRepo creates a new mock instance.
func NewMockAuditRepo(ctrl *gomock.Controller) *MockAuditRepo {
	mock := &MockAuditRepo{ctrl: ctrl}
	mock.recorder = &MockAuditRepoMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAuditRepo) EXPECT() *MockAuditRepoMockRecorder {
	return m.recorder
}

// CountActorAuditLogs mocks base method.
func (m *MockAuditRepo) CountActorAuditLogs(ctx context.Context, actor, actorId string) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CountActorAuditLogs", ctx, actor, actorId)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CountActorAuditLogs indicates an expected call of CountActorAuditLogs.
func (mr *MockAuditRepoMockRecorder) CountActorAuditLogs(ctx, actor, actorId any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountActorAuditLogs", reflect.TypeOf((*MockAuditRepo)(nil).CountActorAuditLogs), ctx, actor, actorId)
}

// CountRecordAuditLogs mocks base method.
func (m *MockAuditRepo) CountRecordAuditLogs(ctx context.Context, tableName, recordId string) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CountRecordAuditLogs", ctx, tableName, recordId)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CountRecordAuditLogs indicates an expected call of CountRecordAuditLogs.
func (mr *MockAuditRepoMockRecorder) CountRecordAuditLogs(ctx, tableName, recordId any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountRecordAuditLogs", reflect.TypeOf((*MockAuditRepo)(nil).CountRecordAuditLogs), ctx, tableName, recordId)
}

// CountTableAuditLogs mocks base method.
func (m *MockAuditRepo) CountTableAuditLogs(ctx context.Context, tableName string) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CountTableAuditLogs", ctx, tableName)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CountTableAuditLogs indicates an expected call of CountTableAuditLogs.
func (mr *MockAuditRepoMockRecorder) CountTableAuditLogs(ctx, tableName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountTableAuditLogs", reflect.TypeOf((*MockAuditRepo)(nil).CountTableAuditLogs), ctx, tableName)
}

// FetchActorAuditLogs mocks base method.
func (m *MockAuditRepo) FetchActorAuditLogs(ctx context.Context, actor, actorId string, page, limit int) ([]model.Audit, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchActorAuditLogs", ctx, actor, actorId, page, limit)
	ret0, _ := ret[0].([]model.Audit)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchActorAuditLogs indicates an expected call of FetchActorAuditLogs.
func (mr *MockAuditRepoMockRecorder) FetchActorAuditLogs(ctx, actor, actorId, page, limit any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchActorAuditLogs", reflect.TypeOf((*MockAuditRepo)(nil).FetchActorAuditLogs), ctx, actor, actorId, page, limit)
}

// FetchRecordAuditLogs mocks base method.
func (m *MockAuditRepo) FetchRecordAuditLogs(ctx context.Context, tableName, recordId string, page, limit int) ([]model.Audit, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchRecordAuditLogs", ctx, tableName, recordId, page, limit)
	ret0, _ := ret[0].([]model.Audit)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchRecordAuditLogs indicates an expected call of FetchRecordAuditLogs.
func (mr *MockAuditRepoMockRecorder) FetchRecordAuditLogs(ctx, tableName, recordId, page, limit any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchRecordAuditLogs", reflect.TypeOf((*MockAuditRepo)(nil).FetchRecordAuditLogs), ctx, tableName, recordId, page, limit)
}

// FetchTableAuditLogs mocks base method.
func (m *MockAuditRepo) FetchTableAuditLogs(ctx context.Context, tableName string, page, limit int) ([]model.Audit, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchTableAuditLogs", ctx, tableName, page, limit)
	ret0, _ := ret[0].([]model.Audit)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchTableAuditLogs indicates an expected call of FetchTableAuditLogs.
func (mr *MockAuditRepoMockRecorder) FetchTableAuditLogs(ctx, tableName, page, limit any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchTableAuditLogs", reflect.TypeOf((*MockAuditRepo)(nil).FetchTableAuditLogs), ctx, tableName, page, limit)
}
